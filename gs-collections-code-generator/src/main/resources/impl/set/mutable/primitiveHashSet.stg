import "copyright.stg"
import "primitiveEquals.stg"
import "primitiveHashCode.stg"
import "primitiveLiteral.stg"

targetPath() ::= "com/gs/collections/impl/set/mutable/primitive"

fileName(primitive) ::= "<primitive.name>HashSet"

class(primitive) ::= <<
<body(primitive.type, primitive.name)>
>>

body(type, name) ::= <<
<copyright()>

package com.gs.collections.impl.set.mutable.primitive;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.util.Arrays;
import java.util.NoSuchElementException;

import com.gs.collections.api.<name>Iterable;
import com.gs.collections.api.Lazy<name>Iterable;
import com.gs.collections.api.bag.primitive.Mutable<name>Bag;
import com.gs.collections.api.block.function.primitive.<name>ToObjectFunction;
import com.gs.collections.api.block.function.primitive.Object<name>ToObjectFunction;
import com.gs.collections.api.block.predicate.primitive.<name>Predicate;
import com.gs.collections.api.block.procedure.primitive.<name>Procedure;
import com.gs.collections.api.iterator.<name>Iterator;
import com.gs.collections.api.list.primitive.Mutable<name>List;
import com.gs.collections.api.set.MutableSet;
import com.gs.collections.api.set.primitive.Immutable<name>Set;
import com.gs.collections.api.set.primitive.Mutable<name>Set;
import com.gs.collections.api.set.primitive.<name>Set;
import com.gs.collections.impl.bag.mutable.primitive.<name>HashBag;
import com.gs.collections.impl.lazy.primitive.Lazy<name>IterableAdapter;
import com.gs.collections.impl.list.mutable.primitive.<name>ArrayList;
import com.gs.collections.impl.set.mutable.UnifiedSet;

/**
 * This file was automatically generated from template file primitiveHashSet.stg.
 *
 * @since 3.0.
 */
public final class <name>HashSet implements Mutable<name>Set, Externalizable
{
    private static final long serialVersionUID = 1L;
    private static final float DEFAULT_LOAD_FACTOR = 0.50f;
    private static final int DEFAULT_INITIAL_CAPACITY = 8;
    private static final <type> EMPTY = <(literal.(type))("0")>;
    private static final <type> REMOVED = <(literal.(type))("1")>;
    private <type>[] table;
    private float loadFactor = DEFAULT_LOAD_FACTOR;
    private int maxSize;
    private int occupied;
    // The 32 bits of this integer indicate whether the items <(literal.(type))("0")> to <(literal.(type))("31")> are present in the set.
    private int zeroToThirtyOne;
    private int zeroToThirtyOneOccupied;

    public <name>HashSet()
    {
        this.allocate(DEFAULT_INITIAL_CAPACITY \<\< 1);
    }

    public <name>HashSet(int initialCapacity)
    {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

    public <name>HashSet(int initialCapacity, float loadFactor)
    {
        if (initialCapacity \< 0)
        {
            throw new IllegalArgumentException("initial capacity cannot be less than 0");
        }
        this.loadFactor = loadFactor;
        this.init(this.fastCeil(initialCapacity / loadFactor));
    }

    public <name>HashSet(<name>HashSet set)
    {
        this.maxSize = set.maxSize;
        this.loadFactor = set.loadFactor;
        this.occupied = set.occupied;
        this.zeroToThirtyOneOccupied = set.zeroToThirtyOneOccupied;
        this.zeroToThirtyOne = set.zeroToThirtyOne;
        this.allocateTable(set.table.length);

        System.arraycopy(set.table, 0, this.table, 0, set.table.length);
    }

    public static <name>HashSet newSetWith(<type>... source)
    {
        <name>HashSet result = new <name>HashSet();
        result.addAll(source);
        return result;
    }

    public static <name>HashSet newSet(<name>Iterable source)
    {
        if (source instanceof <name>HashSet)
        {
            return new <name>HashSet((<name>HashSet) source);
        }

        return <name>HashSet.newSetWith(source.toArray());
    }

    private int fastCeil(float v)
    {
        int possibleResult = (int) v;
        if (v - possibleResult > 0.0F)
        {
            possibleResult++;
        }
        return possibleResult;
    }

    private int init(int initialCapacity)
    {
        int capacity = 1;
        while (capacity \< initialCapacity)
        {
            capacity \<\<= 1;
        }

        return this.allocate(capacity);
    }

    private int allocate(int capacity)
    {
        this.allocateTable(capacity);
        this.computeMaxSize(capacity);
        return capacity;
    }

    private void allocateTable(int sizeToAllocate)
    {
        this.table = new <type>[sizeToAllocate];
    }

    private void computeMaxSize(int capacity)
    {
        // need at least one free slot for open addressing
        this.maxSize = Math.min(capacity - 1, (int) (capacity * this.loadFactor));
    }

    private static boolean isBetweenZeroAndThirtyOne(<type> value)
    {
        return <(betweenZeroAndThirtyOne.(type))("value")>;
    }

    private static boolean isNonSentinel(<type> value)
    {
        return <(notEquals.(type))("value", "EMPTY")> && <(notEquals.(type))("value", "REMOVED")>;
    }

    public int size()
    {
        return this.occupied + this.zeroToThirtyOneOccupied;
    }

    public boolean isEmpty()
    {
        return this.size() == 0;
    }

    public boolean notEmpty()
    {
        return this.size() != 0;
    }

    public void clear()
    {
        this.zeroToThirtyOneOccupied = 0;
        this.occupied = 0;

        this.zeroToThirtyOne = 0;
        Arrays.fill(this.table, EMPTY);
    }

    public boolean contains(<type> value)
    {
        if (isBetweenZeroAndThirtyOne(value))
        {
            int temp = this.zeroToThirtyOne;
            return ((temp >\>> <(castRealTypeToInt.(type))("value")>) & 1) != 0;
        }
        return <(equals.(type))("this.table[this.probe(value)]", "value")>;
    }

    public boolean containsAll(<type>... source)
    {
        for (<type> item : source)
        {
            if (!this.contains(item))
            {
                return false;
            }
        }
        return true;
    }

    public boolean containsAll(<name>Iterable source)
    {
        for (<name>Iterator iterator = source.<type>Iterator(); iterator.hasNext();)
        {
            if (!this.contains(iterator.next()))
            {
                return false;
            }
        }
        return true;
    }

    public boolean add(<type> element)
    {
        if (isBetweenZeroAndThirtyOne(element))
        {
            int initial = this.zeroToThirtyOne;
            this.zeroToThirtyOne |= 1 \<\< <(castRealTypeToInt.(type))("element")>;
            if (this.zeroToThirtyOne != initial)
            {
                this.zeroToThirtyOneOccupied++;
                return true;
            }
            return false;
        }

        int index = this.probe(element);

        if (<(equals.(type))("this.table[index]", "element")>)
        {
            // element already present in set
            return false;
        }

        this.table[index] = element;
        ++this.occupied;
        if (this.occupied > this.maxSize)
        {
            this.rehash();
        }
        return true;
    }

    public boolean addAll(<name>Iterable source)
    {
        if (source.isEmpty())
        {
            return false;
        }
        int oldSize = this.size();
        if (source instanceof <name>HashSet)
        {
            <name>HashSet hashSet = (<name>HashSet) source;
            this.zeroToThirtyOne |= hashSet.zeroToThirtyOne;
            this.zeroToThirtyOneOccupied = Integer.bitCount(this.zeroToThirtyOne);
            for (<type> item : hashSet.table)
            {
                if (isNonSentinel(item))
                {
                    this.add(item);
                }
            }
        }
        else
        {
            <name>Iterator iterator = source.<type>Iterator();
            while (iterator.hasNext())
            {
                <type> item = iterator.next();
                this.add(item);
            }
        }
        return this.size() != oldSize;
    }

    public boolean addAll(<type>... source)
    {
        int oldSize = this.size();
        for (<type> item : source)
        {
            this.add(item);
        }
        return this.size() != oldSize;
    }

    public boolean remove(<type> value)
    {
        if (isBetweenZeroAndThirtyOne(value))
        {
            int initial = this.zeroToThirtyOne;
            this.zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
            if (this.zeroToThirtyOne == initial)
            {
                return false;
            }
            this.zeroToThirtyOneOccupied--;
            return true;
        }
        int index = this.probe(value);
        if (<(equals.(type))("this.table[index]", "value")>)
        {
            this.table[index] = REMOVED;
            this.occupied--;
            return true;
        }
        return false;
    }

    public boolean removeAll(<name>Iterable source)
    {
        if (source.isEmpty())
        {
            return false;
        }
        int oldSize = this.size();
        if (source instanceof <name>HashSet)
        {
            <name>HashSet hashSet = (<name>HashSet) source;
            this.zeroToThirtyOne &= ~hashSet.zeroToThirtyOne;
            this.zeroToThirtyOneOccupied = Integer.bitCount(this.zeroToThirtyOne);
            for (<type> item : hashSet.table)
            {
                if (isNonSentinel(item))
                {
                    this.remove(item);
                }
            }
        }
        else
        {
            <name>Iterator iterator = source.<type>Iterator();
            while (iterator.hasNext())
            {
                <type> item = iterator.next();
                this.remove(item);
            }
        }
        return this.size() != oldSize;
    }

    public boolean removeAll(<type>... source)
    {
        if (source.length == 0)
        {
            return false;
        }
        int oldSize = this.size();
        for (<type> item : source)
        {
            this.remove(item);
        }
        return this.size() != oldSize;
    }

    private void rehash()
    {
        this.rehash(this.table.length \<\< 1);
    }

    private void rehash(int newCapacity)
    {
        int oldLength = this.table.length;
        <type>[] old = this.table;
        this.allocate(newCapacity);
        this.occupied = 0;

        for (int i = 0; i \< oldLength; i++)
        {
            if (isNonSentinel(old[i]))
            {
                this.add(old[i]);
            }
        }
    }

    // exposed for testing
    int probe(<type> element)
    {
        int index = this.spread(element);
        <type> valueAtIndex = this.table[index];

        if (<(equals.(type))("valueAtIndex", "element")> || <(equals.(type))("valueAtIndex", "EMPTY")>)
        {
            return index;
        }

        int removedIndex = <(equals.(type))("valueAtIndex", "REMOVED")> ? index : -1;
        int nextIndex = index;
        int probe = 17;

        // loop until an empty slot is reached
        while (true)
        {
            // Probe algorithm: 17 * n * (n+1) / 2 where n = number of collisions
            nextIndex = (nextIndex + probe) & this.table.length - 1;
            probe += 17;

            if (<(equals.(type))("this.table[nextIndex]", "element")>)
            {
                return nextIndex;
            }
            if (<(equals.(type))("this.table[nextIndex]", "REMOVED")>)
            {
                if (removedIndex == -1)
                {
                    removedIndex = nextIndex;
                }
            }
            else if (<(equals.(type))("this.table[nextIndex]", "EMPTY")>)
            {
                return removedIndex == -1 ? nextIndex : removedIndex;
            }
        }
    }

    // exposed for testing
    <(spread.(type))(type, "table")>

    public <name>HashSet with(<type> element)
    {
        this.add(element);
        return this;
    }

    public <name>HashSet without(<type> element)
    {
        this.remove(element);
        return this;
    }

    public <name>HashSet withAll(<name>Iterable elements)
    {
        this.addAll(elements.toArray());
        return this;
    }

    public <name>HashSet withoutAll(<name>Iterable elements)
    {
        this.removeAll(elements);
        return this;
    }

    public <name>Iterator <type>Iterator()
    {
        return new Internal<name>Iterator();
    }

    public void forEach(<name>Procedure procedure)
    {
        int zeroToThirtyOne = this.zeroToThirtyOne;
        while (zeroToThirtyOne != 0)
        {
            <type> value = <(castFromInt.(type))("Integer.numberOfTrailingZeros(zeroToThirtyOne)")>;
            procedure.value(value);
            zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
        }

        for (<type> value : this.table)
        {
            if (isNonSentinel(value))
            {
                procedure.value(value);
            }
        }
    }

    public \<T> T injectInto(T injectedValue, Object<name>ToObjectFunction\<? super T, ? extends T> function)
    {
        T result = injectedValue;
        int zeroToThirtyOne = this.zeroToThirtyOne;
        while (zeroToThirtyOne != 0)
        {
            <type> value = <(castFromInt.(type))("Integer.numberOfTrailingZeros(zeroToThirtyOne)")>;
            result = function.valueOf(result, value);
            zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
        }

        for (<type> value : this.table)
        {
            if (isNonSentinel(value))
            {
                result = function.valueOf(result, value);
            }
        }
        return result;
    }

    public int count(<name>Predicate predicate)
    {
        int count = 0;
        int zeroToThirtyOne = this.zeroToThirtyOne;
        while (zeroToThirtyOne != 0)
        {
            <type> value = <(castFromInt.(type))("Integer.numberOfTrailingZeros(zeroToThirtyOne)")>;
            if (predicate.accept(value))
            {
                count++;
            }
            zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
        }

        for (<type> value : this.table)
        {
            if (isNonSentinel(value))
            {
                if (predicate.accept(value))
                {
                    count++;
                }
            }
        }
        return count;
    }

    public boolean anySatisfy(<name>Predicate predicate)
    {
        int zeroToThirtyOne = this.zeroToThirtyOne;
        while (zeroToThirtyOne != 0)
        {
            <type> value = <(castFromInt.(type))("Integer.numberOfTrailingZeros(zeroToThirtyOne)")>;
            if (predicate.accept(value))
            {
                return true;
            }
            zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
        }

        for (<type> value : this.table)
        {
            if (isNonSentinel(value))
            {
                if (predicate.accept(value))
                {
                    return true;
                }
            }
        }
        return false;
    }

    public boolean allSatisfy(<name>Predicate predicate)
    {
        int zeroToThirtyOne = this.zeroToThirtyOne;
        while (zeroToThirtyOne != 0)
        {
            <type> value = <(castFromInt.(type))("Integer.numberOfTrailingZeros(zeroToThirtyOne)")>;
            if (!predicate.accept(value))
            {
                return false;
            }
            zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
        }

        for (<type> value : this.table)
        {
            if (isNonSentinel(value))
            {
                if (!predicate.accept(value))
                {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean noneSatisfy(<name>Predicate predicate)
    {
        int zeroToThirtyOne = this.zeroToThirtyOne;
        while (zeroToThirtyOne != 0)
        {
            <type> value = <(castFromInt.(type))("Integer.numberOfTrailingZeros(zeroToThirtyOne)")>;
            if (predicate.accept(value))
            {
                return false;
            }
            zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
        }

        for (<type> value : this.table)
        {
            if (isNonSentinel(value))
            {
                if (predicate.accept(value))
                {
                    return false;
                }
            }
        }
        return true;
    }

    public <name>HashSet select(<name>Predicate predicate)
    {
        <name>HashSet result = new <name>HashSet();

        int zeroToThirtyOne = this.zeroToThirtyOne;
        while (zeroToThirtyOne != 0)
        {
            <type> value = <(castFromInt.(type))("Integer.numberOfTrailingZeros(zeroToThirtyOne)")>;
            if (predicate.accept(value))
            {
                result.add(value);
            }
            zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
        }

        for (<type> value : this.table)
        {
            if (isNonSentinel(value))
            {
                if (predicate.accept(value))
                {
                    result.add(value);
                }
            }
        }
        return result;
    }

    public Mutable<name>Set reject(<name>Predicate predicate)
    {
        <name>HashSet result = new <name>HashSet();

        int zeroToThirtyOne = this.zeroToThirtyOne;
        while (zeroToThirtyOne != 0)
        {
            <type> value = <(castFromInt.(type))("Integer.numberOfTrailingZeros(zeroToThirtyOne)")>;
            if (!predicate.accept(value))
            {
                result.add(value);
            }
            zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
        }

        for (<type> value : this.table)
        {
            if (isNonSentinel(value))
            {
                if (!predicate.accept(value))
                {
                    result.add(value);
                }
            }
        }
        return result;
    }

    public <type> detectIfNone(<name>Predicate predicate, <type> ifNone)
    {
        int zeroToThirtyOne = this.zeroToThirtyOne;
        while (zeroToThirtyOne != 0)
        {
            <type> value = <(castFromInt.(type))("Integer.numberOfTrailingZeros(zeroToThirtyOne)")>;
            if (predicate.accept(value))
            {
                return value;
            }
            zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
        }

        for (<type> value : this.table)
        {
            if (isNonSentinel(value))
            {
                if (predicate.accept(value))
                {
                    return value;
                }
            }
        }
        return ifNone;
    }

    public \<V> MutableSet\<V> collect(<name>ToObjectFunction\<? extends V> function)
    {
        MutableSet\<V> target = UnifiedSet.newSet(this.size());

        int zeroToThirtyOne = this.zeroToThirtyOne;
        while (zeroToThirtyOne != 0)
        {
            <type> value = <(castFromInt.(type))("Integer.numberOfTrailingZeros(zeroToThirtyOne)")>;
            target.add(function.valueOf(value));
            zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
        }

        for (<type> value : this.table)
        {
            if (isNonSentinel(value))
            {
                target.add(function.valueOf(value));
            }
        }
        return target;
    }

    public <wideType.(type)> sum()
    {
        <wideType.(type)> result = <wideZero.(type)>;

        int zeroToThirtyOne = this.zeroToThirtyOne;
        while (zeroToThirtyOne != 0)
        {
            <type> value = <(castFromInt.(type))("Integer.numberOfTrailingZeros(zeroToThirtyOne)")>;
            result += value;
            zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
        }

        for (<type> value : this.table)
        {
            if (isNonSentinel(value))
            {
                result += value;
            }
        }
        return result;
    }

    public <type> max()
    {
        if (this.isEmpty())
        {
            throw new NoSuchElementException();
        }
        <type> max = <(castIntToNarrowType.(type))("31 - Integer.numberOfLeadingZeros(this.zeroToThirtyOne)")>;
        boolean isMaxSet = this.zeroToThirtyOneOccupied != 0;

        for (<type> value : this.table)
        {
            if (isNonSentinel(value) && (!isMaxSet || <(lessThan.(type))("max", "value")>))
            {
                max = value;
                isMaxSet = true;
            }
        }
        return max;
    }

    public <type> min()
    {
        if (this.isEmpty())
        {
            throw new NoSuchElementException();
        }
        <type> min = <(castFromInt.(type))("Integer.numberOfTrailingZeros(this.zeroToThirtyOne)")>;
        boolean isMinSet = this.zeroToThirtyOneOccupied != 0;

        for (<type> value : this.table)
        {
            if (isNonSentinel(value) && (!isMinSet || <(lessThan.(type))("value", "min")>))
            {
                min = value;
                isMinSet = true;
            }
        }
        return min;
    }

    public <type> minIfEmpty(<type> defaultValue)
    {
        if (this.isEmpty())
        {
            return defaultValue;
        }
        return this.min();
    }

    public <type> maxIfEmpty(<type> defaultValue)
    {
        if (this.isEmpty())
        {
            return defaultValue;
        }
        return this.max();
    }

    public double average()
    {
        if (this.isEmpty())
        {
            throw new ArithmeticException();
        }
        return <castSum.(type)>this.sum() / (double) this.size();
    }

    public double median()
    {
        if (this.isEmpty())
        {
            throw new ArithmeticException();
        }
        <type>[] sortedArray = this.toSortedArray();
        int middleIndex = sortedArray.length >\> 1;
        if (sortedArray.length > 1 && (sortedArray.length & 1) == 0)
        {
            <type> first = sortedArray[middleIndex];
            <type> second = sortedArray[middleIndex - 1];
            return (<castDouble.(type)>first + <castDouble.(type)>second) / 2.0;
        }
        return <castDouble.(type)>sortedArray[middleIndex];
    }

    public <type>[] toArray()
    {
        <type>[] array = new <type>[this.size()];

        int j = 0;
        int zeroToThirtyOne = this.zeroToThirtyOne;
        while (zeroToThirtyOne != 0)
        {
            <type> value = <(castFromInt.(type))("Integer.numberOfTrailingZeros(zeroToThirtyOne)")>;
            array[j] = value;
            j++;
            zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
        }

        for (int i = 0; i \< this.table.length && j \< this.size(); i++)
        {
            if (isNonSentinel(this.table[i]))
            {
                array[j] = this.table[i];
                j++;
            }
        }
        return array;
    }

    public <type>[] toSortedArray()
    {
        <type>[] array = this.toArray();
        Arrays.sort(array);
        return array;
    }

    @Override
    public boolean equals(Object obj)
    {
        if (this == obj)
        {
            return true;
        }

        if (!(obj instanceof <name>Set))
        {
            return false;
        }

        <name>Set other = (<name>Set) obj;
        return this.size() == other.size() && this.containsAll(other.toArray());
    }

    @Override
    public int hashCode()
    {
        int result = 0;
        int zeroToThirtyOne = this.zeroToThirtyOne;
        while (zeroToThirtyOne != 0)
        {
            <type> value = <(castFromInt.(type))("Integer.numberOfTrailingZeros(zeroToThirtyOne)")>;
            result += <(hashCode.(type))("value")>;
            zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
        }
        if (this.table != null)
        {
            for (int i = 0; i \< this.table.length; i++)
            {
                if (isNonSentinel(this.table[i]))
                {
                    result += <(hashCode.(type))("this.table[i]")>;
                }
            }
        }
        return result;
    }

    @Override
    public String toString()
    {
        return this.makeString("[", ", ", "]");
    }

    public String makeString()
    {
        return this.makeString(", ");
    }

    public String makeString(String separator)
    {
        return this.makeString("", separator, "");
    }

    public String makeString(String start, String separator, String end)
    {
        Appendable stringBuilder = new StringBuilder();
        this.appendString(stringBuilder, start, separator, end);
        return stringBuilder.toString();
    }

    public void appendString(Appendable appendable)
    {
        this.appendString(appendable, ", ");
    }

    public void appendString(Appendable appendable, String separator)
    {
        this.appendString(appendable, "", separator, "");
    }

    public void appendString(Appendable appendable, String start, String separator, String end)
    {
        try
        {
            appendable.append(start);

            int count = 0;
            int zeroToThirtyOne = this.zeroToThirtyOne;
            while (zeroToThirtyOne != 0)
            {
                <type> value = <(castFromInt.(type))("Integer.numberOfTrailingZeros(zeroToThirtyOne)")>;
                if (count > 0)
                {
                    appendable.append(separator);
                }
                count++;
                appendable.append(String.valueOf(value));
                zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
            }

            for (<type> value : this.table)
            {
                if (isNonSentinel(value))
                {
                    if (count > 0)
                    {
                        appendable.append(separator);
                    }
                    count++;
                    appendable.append(String.valueOf(value));
                }
            }
            appendable.append(end);
        }
        catch (IOException e)
        {
            throw new RuntimeException(e);
        }
    }

    public Mutable<name>List toList()
    {
        return <name>ArrayList.newList(this);
    }

    public Mutable<name>List toSortedList()
    {
        return <name>ArrayList.newList(this).sortThis();
    }

    public Mutable<name>Set toSet()
    {
        return <name>HashSet.newSet(this);
    }

    public Mutable<name>Bag toBag()
    {
        return <name>HashBag.newBag(this);
    }

    public Lazy<name>Iterable asLazy()
    {
        return new Lazy<name>IterableAdapter(this);
    }

    public Mutable<name>Set asUnmodifiable()
    {
        return new Unmodifiable<name>Set(this);
    }

    public Mutable<name>Set asSynchronized()
    {
        return new Synchronized<name>Set(this);
    }

    public Immutable<name>Set toImmutable()
    {
        throw new UnsupportedOperationException("toImmutable not implemented yet");
    }

    public void writeExternal(ObjectOutput out) throws IOException
    {
        out.writeInt(this.size());

        int zeroToThirtyOne = this.zeroToThirtyOne;
        while (zeroToThirtyOne != 0)
        {
            <type> value = <(castFromInt.(type))("Integer.numberOfTrailingZeros(zeroToThirtyOne)")>;
            out.write<name>(value);
            zeroToThirtyOne &= ~(1 \<\< <(castRealTypeToInt.(type))("value")>);
        }

        for (<type> value : this.table)
        {
            if (isNonSentinel(value))
            {
                out.write<name>(value);
            }
        }
    }

    public void readExternal(ObjectInput in) throws IOException
    {
        int size = in.readInt();

        for (int i = 0; i \< size; i++)
        {
            this.add(in.read<name>());
        }
    }

    private class Internal<name>Iterator implements <name>Iterator
    {
        private int count;
        private int position;
        private <type> zeroToThirtyOne;

        public boolean hasNext()
        {
            return this.count \< <name>HashSet.this.size();
        }

        public <type> next()
        {
            if (!this.hasNext())
            {
                throw new NoSuchElementException("next() called, but the iterator is exhausted");
            }
            this.count++;

            while (this.zeroToThirtyOne \< 32)
            {
                if (<name>HashSet.this.contains(this.zeroToThirtyOne))
                {
                    <type> result = this.zeroToThirtyOne;
                    this.zeroToThirtyOne++;
                    return result;
                }
                this.zeroToThirtyOne++;
            }

            <type>[] table = <name>HashSet.this.table;
            while (!isNonSentinel(table[this.position]))
            {
                this.position++;
            }
            <type> result = table[this.position];
            this.position++;
            return result;
        }
    }
}

>>

betweenZeroAndThirtyOne ::= [
"byte": "intBetweenZeroAndThirtyOne",
"short": "intBetweenZeroAndThirtyOne",
"char": "intBetweenZeroAndThirtyOne",
"int": "intBetweenZeroAndThirtyOne",
"long": "intBetweenZeroAndThirtyOne",
"float": "floatBetweenZeroAndThirtyOne",
"double": "floatBetweenZeroAndThirtyOne"
]

intBetweenZeroAndThirtyOne(value) ::= <<
value >= <zero.(type)> && value \<= <(literal.(type))("31")>
>>

floatBetweenZeroAndThirtyOne(value) ::= <<
value >= <zero.(type)> && value \<= <(literal.(type))("31")> && Double.compare(value, Math.floor(value)) == 0
>>
