import "copyright.stg"
import "primitiveHashCode.stg"
import "primitiveLiteral.stg"

isTest() ::= "true"

targetPath() ::= "com/gs/collections/impl/map/mutable/primitive"

fileName(primitive) ::= "AbstractMutable<primitive.name>ObjectMapTestCase"

skipBoolean() ::= "true"

class(primitive) ::= <<
<body(primitive.type, primitive.name)>
>>

body(type, name) ::= <<
<copyright()>

package com.gs.collections.impl.map.mutable.primitive;

import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.concurrent.atomic.AtomicInteger;

import com.gs.collections.api.RichIterable;
import com.gs.collections.api.block.function.Function;
import com.gs.collections.api.block.function.Function0;
import com.gs.collections.api.block.function.Function2;
import com.gs.collections.api.block.function.primitive.DoubleFunction;
import com.gs.collections.api.block.function.primitive.DoubleObjectToDoubleFunction;
import com.gs.collections.api.block.function.primitive.FloatFunction;
import com.gs.collections.api.block.function.primitive.FloatObjectToFloatFunction;
import com.gs.collections.api.block.function.primitive.IntFunction;
import com.gs.collections.api.block.function.primitive.IntObjectToIntFunction;
import com.gs.collections.api.block.function.primitive.LongFunction;
import com.gs.collections.api.block.function.primitive.LongObjectToLongFunction;
import com.gs.collections.api.block.function.primitive.<name>ToObjectFunction;
import com.gs.collections.api.block.predicate.Predicate;
import com.gs.collections.api.block.predicate.Predicate2;
import com.gs.collections.api.block.predicate.primitive.<name>ObjectPredicate;
import com.gs.collections.api.block.procedure.Procedure;
import com.gs.collections.api.block.procedure.Procedure2;
import com.gs.collections.api.block.procedure.primitive.ObjectIntProcedure;
import com.gs.collections.api.block.procedure.primitive.<name>ObjectProcedure;
import com.gs.collections.api.block.procedure.primitive.<name>Procedure;
import com.gs.collections.api.map.MapIterable;
import com.gs.collections.api.map.primitive.Mutable<name>ObjectMap;
import com.gs.collections.api.multimap.Multimap;
import com.gs.collections.api.partition.PartitionIterable;
import com.gs.collections.api.tuple.Pair;
import com.gs.collections.impl.bag.mutable.HashBag;
import com.gs.collections.impl.block.factory.Comparators;
import com.gs.collections.impl.block.factory.Functions;
import com.gs.collections.impl.block.factory.Functions0;
import com.gs.collections.impl.block.function.AddFunction;
import com.gs.collections.impl.list.mutable.FastList;
import com.gs.collections.impl.list.mutable.primitive.<name>ArrayList;
import com.gs.collections.impl.map.mutable.UnifiedMap;
import com.gs.collections.impl.multimap.list.FastListMultimap;
import com.gs.collections.impl.set.mutable.UnifiedSet;
import com.gs.collections.impl.set.sorted.mutable.TreeSortedSet;
import com.gs.collections.impl.test.Verify;
import com.gs.collections.impl.tuple.Tuples;
import org.junit.Assert;
import org.junit.Test;

/**
 * This file was automatically generated from template file abstractMutablePrimitiveObjectMapTestCase.stg.
 */
public abstract class AbstractMutable<name>ObjectMapTestCase
{
    private final Mutable<name>ObjectMap\<String> map = this.classUnderTest();

    protected abstract Mutable<name>ObjectMap\<String> classUnderTest();

    protected abstract \<T> Mutable<name>ObjectMap\<T> newWithKeysValues(<type> key1, T value1);
                                                    
    protected abstract \<T> Mutable<name>ObjectMap\<T> newWithKeysValues(<type> key1, T value1, <type> key2, T value2);
                                                    
    protected abstract \<T> Mutable<name>ObjectMap\<T> newWithKeysValues(<type> key1, T value1, <type> key2, T value2, <type> key3, T value3);
                                                    
    protected abstract \<T> Mutable<name>ObjectMap\<T> getEmptyMap();

    protected static <name>ArrayList generateCollisions()
    {
        <name>ArrayList collisions = new <name>ArrayList();
        <name>ObjectHashMap\<?> hashMap = new <name>ObjectHashMap\<Object>();
        for (<type> i = <(literal.(type))("2")>; collisions.size() \<= 10; i++)
        {
            if (hashMap.spread(i) == hashMap.spread(<(literal.(type))("2")>))
            {
                collisions.add(i);
            }
        }
        return collisions;
    }

    @Test
    public void clear()
    {
        Mutable<name>ObjectMap\<Object> hashMap = this.getEmptyMap();
        hashMap.put(<(literal.(type))("0")>, new Object());
        hashMap.clear();
        Assert.assertEquals(new <name>ObjectHashMap\<Object>(), hashMap);

        hashMap.put(<(literal.(type))("1")>, new Object());
        hashMap.clear();
        Assert.assertEquals(new <name>ObjectHashMap\<Object>(), hashMap);

        hashMap.put(<(literal.(type))("33")>, new Object());
        hashMap.clear();
        Assert.assertEquals(new <name>ObjectHashMap\<Object>(), hashMap);
    }

    @Test
    public void removeKey()
    {
        Assert.assertNull(this.map.removeKey(<(literal.(type))("5")>));
        Assert.assertNull(this.map.removeKey(<(literal.(type))("50")>));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("31")>, "thirtyOne", <(literal.(type))("32")>, "thirtyTwo"), this.map);
        Assert.assertEquals("zero", this.map.removeKey(<(literal.(type))("0")>));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("31")>, "thirtyOne", <(literal.(type))("32")>, "thirtyTwo"), this.map);
        Assert.assertEquals("thirtyOne", this.map.removeKey(<(literal.(type))("31")>));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("32")>, "thirtyTwo"), this.map);
        Assert.assertEquals("thirtyTwo", this.map.removeKey(<(literal.(type))("32")>));
        Assert.assertEquals(new <name>ObjectHashMap\<String>(), this.map);
        Assert.assertNull(this.map.removeKey(<(literal.(type))("0")>));
        Assert.assertNull(this.map.removeKey(<(literal.(type))("1")>));
        Assert.assertNull(this.map.removeKey(<(literal.(type))("31")>));
        Assert.assertNull(this.map.removeKey(<(literal.(type))("32")>));
        Assert.assertEquals(new <name>ObjectHashMap\<String>(), this.map);
        Assert.assertTrue(this.map.isEmpty());

        Assert.assertNull(this.map.put(<(literal.(type))("1")>, null));
        Assert.assertTrue(this.map.containsValue(null));
        Assert.assertNull(this.map.removeKey(<(literal.(type))("1")>));
        Assert.assertFalse(this.map.containsValue(null));

        Assert.assertNull(this.map.put(<(literal.(type))("0")>, null));
        Assert.assertTrue(this.map.containsValue(null));
        Assert.assertNull(this.map.removeKey(<(literal.(type))("0")>));
        Assert.assertFalse(this.map.containsValue(null));

        Assert.assertNull(this.map.put(<(literal.(type))("35")>, null));
        Assert.assertTrue(this.map.containsValue(null));
        Assert.assertNull(this.map.removeKey(<(literal.(type))("35")>));
        Assert.assertFalse(this.map.containsValue(null));

        Assert.assertNull(this.map.put(AbstractMutable<name>ObjectMapTestCase.generateCollisions().getFirst(), "collision1"));
        Assert.assertNull(this.map.put(AbstractMutable<name>ObjectMapTestCase.generateCollisions().get(1), "collision2"));
        Assert.assertEquals("collision2", this.map.removeKey(AbstractMutable<name>ObjectMapTestCase.generateCollisions().get(1)));
        Assert.assertEquals("collision1", this.map.removeKey(AbstractMutable<name>ObjectMapTestCase.generateCollisions().getFirst()));

        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one");
        Assert.assertEquals("zero", map1.removeKey(<(literal.(type))("0")>));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one"), map1);
        Assert.assertEquals("one", map1.removeKey(<(literal.(type))("1")>));
        Assert.assertEquals(<name>ObjectHashMap.newMap(), map1);
    }

    @Test
    public void put()
    {
        Assert.assertEquals("zero", this.map.put(<(literal.(type))("0")>, "one"));
        Assert.assertEquals("thirtyOne", this.map.put(<(literal.(type))("31")>, "thirtyTwo"));
        Assert.assertEquals("thirtyTwo", this.map.put(<(literal.(type))("32")>, "thirtyThree"));
        <name>ObjectHashMap\<String> expected = <name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "one", <(literal.(type))("31")>, "thirtyTwo", <(literal.(type))("32")>, "thirtyThree");
        Assert.assertEquals(expected, this.map);

        Assert.assertNull(this.map.put(<(literal.(type))("1")>, "two"));
        Assert.assertEquals("two", this.map.put(<(literal.(type))("1")>, "two"));
        expected.put(<(literal.(type))("1")>, "two");
        Assert.assertEquals(expected, this.map);

        Assert.assertNull(this.map.put(<(literal.(type))("33")>, "thirtyFour"));
        expected.put(<(literal.(type))("33")>, "thirtyFour");
        Assert.assertEquals(expected, this.map);

        Assert.assertNull(this.map.put(<(literal.(type))("30")>, "thirtyOne"));
        expected.put(<(literal.(type))("30")>, "thirtyOne");
        Assert.assertEquals(expected, this.map);

        Assert.assertNull(this.map.put(<(literal.(type))("5")>, null));
        expected.put(<(literal.(type))("5")>, null);
        Assert.assertEquals(expected, this.map);

        Assert.assertNull(this.map.put(<(literal.(type))("50")>, null));
        expected.put(<(literal.(type))("50")>, null);
        Assert.assertEquals(expected, this.map);

        Mutable<name>ObjectMap\<String> emptyMap = <name>ObjectHashMap.newMap();
        Assert.assertNull(emptyMap.put(<(literal.(type))("0")>, "zero"));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero"), emptyMap);
        Mutable<name>ObjectMap\<String> emptyMap1 = <name>ObjectHashMap.newMap();
        Assert.assertNull(emptyMap1.put(<(literal.(type))("1")>, "one"));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one"), emptyMap1);
        Assert.assertNull(emptyMap1.put(<(literal.(type))("0")>, "zero"));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one"), emptyMap1);
    }

    @Test
    public void putDuplicateWithRemovedSlot()
    {
        <type> collision1 = AbstractMutable<name>ObjectMapTestCase.generateCollisions().getFirst();
        <type> collision2 = AbstractMutable<name>ObjectMapTestCase.generateCollisions().get(1);
        <type> collision3 = AbstractMutable<name>ObjectMapTestCase.generateCollisions().get(2);
        <type> collision4 = AbstractMutable<name>ObjectMapTestCase.generateCollisions().get(3);

        Mutable<name>ObjectMap\<String> hashMap = <name>ObjectHashMap.newMap();
        Assert.assertNull(hashMap.put(collision1, "collision1"));
        Assert.assertNull(hashMap.put(collision2, "collision2"));
        Assert.assertNull(hashMap.put(collision3, "collision3"));
        Assert.assertEquals("collision2", hashMap.removeKey(collision2));
        Assert.assertNull(hashMap.put(collision4, "collision4"));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(collision1, "collision1", collision3, "collision3", collision4, "collision4"), hashMap);

        Mutable<name>ObjectMap\<String> hashMap1 = <name>ObjectHashMap.newMap();
        Assert.assertNull(hashMap1.put(collision1, "collision1"));
        Assert.assertNull(hashMap1.put(collision2, "collision2"));
        Assert.assertNull(hashMap1.put(collision3, "collision3"));
        Assert.assertEquals("collision1", hashMap1.removeKey(collision1));
        Assert.assertNull(hashMap1.put(collision4, "collision4"));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(collision2, "collision2", collision3, "collision3", collision4, "collision4"), hashMap1);

        Mutable<name>ObjectMap\<String> hashMap2 = <name>ObjectHashMap.newMap();
        Assert.assertNull(hashMap2.put(collision1, "collision1"));
        Assert.assertNull(hashMap2.put(collision2, "collision2"));
        Assert.assertNull(hashMap2.put(collision3, "collision3"));
        Assert.assertEquals("collision3", hashMap2.removeKey(collision3));
        Assert.assertNull(hashMap2.put(collision4, "collision4"));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(collision1, "collision1", collision2, "collision2", collision4, "collision4"), hashMap2);
    }

    @Test
    public void getIfAbsentPut()
    {
        Assert.assertEquals("zero", this.map.getIfAbsentPut(<(literal.(type))("0")>, new Function0\<String>()
        {
            public String value()
            {
                return "zeroValue";
            }
        }));
        Mutable<name>ObjectMap\<String> expected = <name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("31")>, "thirtyOne", <(literal.(type))("32")>, "thirtyTwo");
        Assert.assertEquals(expected, this.map);

        Assert.assertEquals("oneValue", this.map.getIfAbsentPut(<(literal.(type))("1")>, new Function0\<String>()
        {
            public String value()
            {
                return "oneValue";
            }
        }));
        expected.put(<(literal.(type))("1")>, "oneValue");
        Assert.assertEquals(expected, this.map);

        Assert.assertNull(this.map.getIfAbsentPut(<(literal.(type))("2")>, new Function0\<String>()
        {
            public String value()
            {
                return null;
            }
        }));
        expected.put(<(literal.(type))("2")>, null);
        Assert.assertEquals(expected, this.map);

        Assert.assertEquals("thirtyTwo", this.map.getIfAbsentPut(<(literal.(type))("32")>, new Function0\<String>()
        {
            public String value()
            {
                return "thirtyTwoValue";
            }
        }));
        Assert.assertEquals(expected, this.map);

        Assert.assertEquals("thirtyThreeValue", this.map.getIfAbsentPut(<(literal.(type))("33")>, new Function0\<String>()
        {
            public String value()
            {
                return "thirtyThreeValue";
            }
        }));
        expected.put(<(literal.(type))("33")>, "thirtyThreeValue");
        Assert.assertEquals(expected, this.map);

        Assert.assertNull(this.map.getIfAbsentPut(<(literal.(type))("34")>, new Function0\<String>()
        {
            public String value()
            {
                return null;
            }
        }));
        expected.put(<(literal.(type))("34")>, null);
        Assert.assertEquals(expected, this.map);

        Mutable<name>ObjectMap\<String> emptyMap = <name>ObjectHashMap.newMap();
        Assert.assertEquals("zeroValue", emptyMap.getIfAbsentPut(<(literal.(type))("0")>, new Function0\<String>()
        {
            public String value()
            {
                return "zeroValue";
            }
        }));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zeroValue"), emptyMap);

        Assert.assertEquals("oneValue", emptyMap.getIfAbsentPut(<(literal.(type))("1")>, new Function0\<String>()
        {
            public String value()
            {
                return "oneValue";
            }
        }));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zeroValue", <(literal.(type))("1")>, "oneValue"), emptyMap);

        Assert.assertEquals("oneValue", emptyMap.getIfAbsentPut(<(literal.(type))("1")>, new Function0\<String>()
        {
            public String value()
            {
                return "twoValue";
            }
        }));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zeroValue", <(literal.(type))("1")>, "oneValue"), emptyMap);
        Assert.assertEquals("zeroValue", emptyMap.removeKey(<(literal.(type))("0")>));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "oneValue"), emptyMap);
        Assert.assertEquals("zeroValue", emptyMap.getIfAbsentPut(<(literal.(type))("0")>, new Function0\<String>()
        {
            public String value()
            {
                return "zeroValue";
            }
        }));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zeroValue", <(literal.(type))("1")>, "oneValue"), emptyMap);

        Mutable<name>ObjectMap\<String> emptyMap1 = <name>ObjectHashMap.newMap();
        Assert.assertEquals("oneValue", emptyMap1.getIfAbsentPut(<(literal.(type))("1")>, new Function0\<String>()
        {
            public String value()
            {
                return "oneValue";
            }
        }));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "oneValue"), emptyMap1);
    }

    @Test
    public void getIfAbsentPutWith()
    {
        Function\<String, String> toUpperCase = new Function\<String, String>()
        {
            public String valueOf(String string)
            {
                return string.toUpperCase();
            }
        };
        Assert.assertEquals("zero", this.map.getIfAbsentPutWith(<(literal.(type))("0")>, toUpperCase, "zeroValue"));
        <name>ObjectHashMap\<String> expected = <name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("31")>, "thirtyOne", <(literal.(type))("32")>, "thirtyTwo");
        Assert.assertEquals(expected, this.map);

        Assert.assertEquals("ONEVALUE", this.map.getIfAbsentPutWith(<(literal.(type))("1")>, toUpperCase, "oneValue"));
        expected.put(<(literal.(type))("1")>, "ONEVALUE");
        Assert.assertEquals(expected, this.map);

        Assert.assertNull(this.map.getIfAbsentPutWith(<(literal.(type))("2")>, new Function\<String, String>()
        {
            public String valueOf(String string)
            {
                return null;
            }
        }, ""));
        expected.put(<(literal.(type))("2")>, null);
        Assert.assertEquals(expected, this.map);

        Assert.assertEquals("thirtyTwo", this.map.getIfAbsentPutWith(<(literal.(type))("32")>, toUpperCase, "thirtyTwoValue"));
        Assert.assertEquals(expected, this.map);

        Assert.assertEquals("THIRTYTHREEVALUE", this.map.getIfAbsentPutWith(<(literal.(type))("33")>, toUpperCase, "thirtyThreeValue"));
        expected.put(<(literal.(type))("33")>, "THIRTYTHREEVALUE");
        Assert.assertEquals(expected, this.map);

        Assert.assertNull(this.map.getIfAbsentPutWith(<(literal.(type))("34")>, new Function\<String, String>()
        {
            public String valueOf(String string)
            {
                return null;
            }
        }, ""));
        expected.put(<(literal.(type))("34")>, null);
        Assert.assertEquals(expected, this.map);

        Mutable<name>ObjectMap\<String> emptyMap = <name>ObjectHashMap.newMap();
        Assert.assertEquals("ZEROVALUE", emptyMap.getIfAbsentPutWith(<(literal.(type))("0")>, toUpperCase, "zeroValue"));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "ZEROVALUE"), emptyMap);

        Assert.assertEquals("ONEVALUE", emptyMap.getIfAbsentPutWith(<(literal.(type))("1")>, toUpperCase, "oneValue"));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "ZEROVALUE", <(literal.(type))("1")>, "ONEVALUE"), emptyMap);

        Assert.assertEquals("ONEVALUE", emptyMap.getIfAbsentPutWith(<(literal.(type))("1")>, toUpperCase, "twoValue"));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "ZEROVALUE", <(literal.(type))("1")>, "ONEVALUE"), emptyMap);

        Assert.assertEquals("ZEROVALUE", emptyMap.removeKey(<(literal.(type))("0")>));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "ONEVALUE"), emptyMap);

        Assert.assertEquals("ZEROVALUE", emptyMap.getIfAbsentPutWith(<(literal.(type))("0")>, toUpperCase, "zeroValue"));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "ZEROVALUE", <(literal.(type))("1")>, "ONEVALUE"), emptyMap);

        Mutable<name>ObjectMap\<String> emptyMap1 = <name>ObjectHashMap.newMap();
        Assert.assertEquals("ONEVALUE", emptyMap1.getIfAbsentPutWith(<(literal.(type))("1")>, toUpperCase, "oneValue"));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "ONEVALUE"), emptyMap1);
    }

    @Test
    public void getIfAbsentPutWithKey()
    {
        <name>ToObjectFunction\<String> toString = new <name>ToObjectFunction\<String>()
        {
            public String valueOf(<type> <type>Parameter)
            {
                return String.valueOf(<type>Parameter);
            }
        };

        Assert.assertEquals("zero", this.map.getIfAbsentPutWithKey(<(literal.(type))("0")>, toString));
        <name>ObjectHashMap\<String> expected = <name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("31")>, "thirtyOne", <(literal.(type))("32")>, "thirtyTwo");
        Assert.assertEquals(expected, this.map);

        Assert.assertEquals("<(toStringLiteral.(type))("1")>", this.map.getIfAbsentPutWithKey(<(literal.(type))("1")>, toString));
        expected.put(<(literal.(type))("1")>, "<(toStringLiteral.(type))("1")>");
        Assert.assertEquals(expected, this.map);

        Assert.assertNull(this.map.getIfAbsentPutWithKey(<(literal.(type))("2")>, new <name>ToObjectFunction\<String>()
        {
            public String valueOf(<type> <type>Parameter)
            {
                return null;
            }
        }));
        expected.put(<(literal.(type))("2")>, null);
        Assert.assertEquals(expected, this.map);

        Assert.assertEquals("thirtyTwo", this.map.getIfAbsentPutWithKey(<(literal.(type))("32")>, toString));
        Assert.assertEquals(expected, this.map);

        Assert.assertEquals("<(toStringLiteral.(type))("33")>", this.map.getIfAbsentPutWithKey(<(literal.(type))("33")>, toString));
        expected.put(<(literal.(type))("33")>, "<(toStringLiteral.(type))("33")>");
        Assert.assertEquals(expected, this.map);

        Assert.assertNull(this.map.getIfAbsentPutWithKey(<(literal.(type))("34")>, new <name>ToObjectFunction\<String>()
        {
            public String valueOf(<type> <type>Parameter)
            {
                return null;
            }
        }));
        expected.put(<(literal.(type))("34")>, null);
        Assert.assertEquals(expected, this.map);

        Mutable<name>ObjectMap\<String> emptyMap = <name>ObjectHashMap.newMap();
        Assert.assertEquals("<(toStringLiteral.(type))("0")>", emptyMap.getIfAbsentPutWithKey(<(literal.(type))("0")>, toString));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "<(toStringLiteral.(type))("0")>"), emptyMap);

        Assert.assertEquals("<(toStringLiteral.(type))("1")>", emptyMap.getIfAbsentPutWithKey(<(literal.(type))("1")>, toString));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "<(toStringLiteral.(type))("0")>", <(literal.(type))("1")>, "<(toStringLiteral.(type))("1")>"), emptyMap);

        Assert.assertEquals("<(toStringLiteral.(type))("1")>", emptyMap.getIfAbsentPutWithKey(<(literal.(type))("1")>, toString));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "<(toStringLiteral.(type))("0")>", <(literal.(type))("1")>, "<(toStringLiteral.(type))("1")>"), emptyMap);

        Assert.assertEquals("<(toStringLiteral.(type))("0")>", emptyMap.removeKey(<(literal.(type))("0")>));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "<(toStringLiteral.(type))("1")>"), emptyMap);
        Assert.assertEquals("<(toStringLiteral.(type))("0")>", emptyMap.getIfAbsentPutWithKey(<(literal.(type))("0")>, toString));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "<(toStringLiteral.(type))("0")>", <(literal.(type))("1")>, "<(toStringLiteral.(type))("1")>"), emptyMap);

        Mutable<name>ObjectMap\<String> emptyMap1 = <name>ObjectHashMap.newMap();
        Assert.assertEquals("<(toStringLiteral.(type))("1")>", emptyMap1.getIfAbsentPutWithKey(<(literal.(type))("1")>, toString));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "<(toStringLiteral.(type))("1")>"), emptyMap1);
    }

    @Test
    public void updateValue()
    {
        Function\<Integer, Integer> incrementFunction = new Function\<Integer, Integer>()
        {
            public Integer valueOf(Integer integer)
            {
                return integer + 1;
            }
        };
        Function0\<Integer> zeroFactory = Functions0.value(0);

        Mutable<name>ObjectMap\<Integer> map1 = this.getEmptyMap();
        Assert.assertEquals(Integer.valueOf(1), map1.updateValue(<(literal.(type))("0")>, zeroFactory, incrementFunction));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, 1), map1);
        Assert.assertEquals(Integer.valueOf(2), map1.updateValue(<(literal.(type))("0")>, zeroFactory, incrementFunction));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, 2), map1);
        Assert.assertEquals(Integer.valueOf(1), map1.updateValue(<(literal.(type))("1")>, zeroFactory, incrementFunction));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, 2, <(literal.(type))("1")>, 1), map1);
        Assert.assertEquals(Integer.valueOf(2), map1.updateValue(<(literal.(type))("1")>, zeroFactory, incrementFunction));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, 2, <(literal.(type))("1")>, 2), map1);

        Mutable<name>ObjectMap\<Integer> map2 = this.getEmptyMap();
        Assert.assertEquals(Integer.valueOf(1), map2.updateValue(<(literal.(type))("1")>, zeroFactory, incrementFunction));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, 1), map2);
        Assert.assertEquals(Integer.valueOf(2), map2.updateValue(<(literal.(type))("1")>, zeroFactory, incrementFunction));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, 2), map2);
        Assert.assertEquals(Integer.valueOf(1), map2.updateValue(<(literal.(type))("0")>, zeroFactory, incrementFunction));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, 1, <(literal.(type))("1")>, 2), map2);
        Assert.assertEquals(Integer.valueOf(2), map2.updateValue(<(literal.(type))("0")>, zeroFactory, incrementFunction));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, 2, <(literal.(type))("1")>, 2), map2);

        Mutable<name>ObjectMap\<Integer> map3 = this.getEmptyMap();
        Assert.assertEquals(Integer.valueOf(1), map3.updateValue(<(literal.(type))("33")>, zeroFactory, incrementFunction));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("33")>, 1), map3);
        Assert.assertEquals(Integer.valueOf(2), map3.updateValue(<(literal.(type))("33")>, zeroFactory, incrementFunction));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("33")>, 2), map3);
    }

    @Test
    public void updateValueWith()
    {
        Function2\<Integer, Integer, Integer> incrementFunction = AddFunction.INTEGER;
        Function0\<Integer> zeroFactory = Functions0.value(0);

        Mutable<name>ObjectMap\<Integer> map1 = this.getEmptyMap();
        Assert.assertEquals(Integer.valueOf(1), map1.updateValueWith(<(literal.(type))("0")>, zeroFactory, incrementFunction, 1));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, 1), map1);
        Assert.assertEquals(Integer.valueOf(2), map1.updateValueWith(<(literal.(type))("0")>, zeroFactory, incrementFunction, 1));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, 2), map1);
        Assert.assertEquals(Integer.valueOf(1), map1.updateValueWith(<(literal.(type))("1")>, zeroFactory, incrementFunction, 1));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, 2, <(literal.(type))("1")>, 1), map1);
        Assert.assertEquals(Integer.valueOf(2), map1.updateValueWith(<(literal.(type))("1")>, zeroFactory, incrementFunction, 1));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, 2, <(literal.(type))("1")>, 2), map1);

        Mutable<name>ObjectMap\<Integer> map2 = this.getEmptyMap();
        Assert.assertEquals(Integer.valueOf(1), map2.updateValueWith(<(literal.(type))("1")>, zeroFactory, incrementFunction, 1));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, 1), map2);
        Assert.assertEquals(Integer.valueOf(2), map2.updateValueWith(<(literal.(type))("1")>, zeroFactory, incrementFunction, 1));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, 2), map2);
        Assert.assertEquals(Integer.valueOf(1), map2.updateValueWith(<(literal.(type))("0")>, zeroFactory, incrementFunction, 1));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, 1, <(literal.(type))("1")>, 2), map2);
        Assert.assertEquals(Integer.valueOf(2), map2.updateValueWith(<(literal.(type))("0")>, zeroFactory, incrementFunction, 1));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, 2, <(literal.(type))("1")>, 2), map2);

        Mutable<name>ObjectMap\<Integer> map3 = this.getEmptyMap();
        Assert.assertEquals(Integer.valueOf(1), map3.updateValueWith(<(literal.(type))("33")>, zeroFactory, incrementFunction, 1));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("33")>, 1), map3);
        Assert.assertEquals(Integer.valueOf(2), map3.updateValueWith(<(literal.(type))("33")>, zeroFactory, incrementFunction, 1));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("33")>, 2), map3);
    }

    @Test
    public void select()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("9")>, "nine");

        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine"), map1.select(new <name>ObjectPredicate\<String>()
        {
            public boolean accept(<type> value, String object)
            {
                return (value % 2) != 0;
            }
        }));

        <name>ObjectPredicate\<String> keyGreaterThanOrEqualToSeven = new <name>ObjectPredicate\<String>()
        {
            public boolean accept(<type> value, String object)
            {
                return value \<= 7;
            }
        };
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one"), map1.select(keyGreaterThanOrEqualToSeven));

        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero"), map2.select(keyGreaterThanOrEqualToSeven));

        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one"), map3.select(keyGreaterThanOrEqualToSeven));

        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("5")>, "five"), map4.select(keyGreaterThanOrEqualToSeven));

        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine"), map1.select(new <name>ObjectPredicate\<String>()
        {
            public boolean accept(<type> value, String object)
            {
                return object.endsWith("ne");
            }
        }));

        RichIterable\<String> actual1 = map1.select(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("ne");
            }
        });
        Assert.assertTrue(FastList.newListWith("one", "nine").equals(actual1) || FastList.newListWith("nine", "one").equals(actual1));

        Assert.assertEquals(FastList.newListWith("nine"), map1.select(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return "nine".equals(each);
            }
        }));

        Assert.assertEquals(FastList.newListWith("zero"), map1.select(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("o");
            }
        }));

        Assert.assertEquals(FastList.newListWith("nine"), map1.select(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return "nine".equals(each);
            }
        }, FastList.\<String>newList()));

        Assert.assertEquals(FastList.newListWith("one", "nine"), map1.select(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("ne");
            }
        }, FastList.\<String>newList()));

        Assert.assertEquals(FastList.newListWith("zero"), map1.select(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("o");
            }
        }, FastList.\<String>newList()));
    }

    @Test
    public void selectWith()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Assert.assertEquals(FastList.newListWith("one", "nine"), map1.selectWith(new Predicate2\<String, String>()
        {
            public boolean accept(String argument1, String argument2)
            {
                return argument1.endsWith(argument2);
            }
        }, "ne", FastList.\<String>newList()));

        Assert.assertEquals(FastList.newListWith("nine"), map1.selectWith(new Predicate2\<String, String>()
        {
            public boolean accept(String argument1, String argument2)
            {
                return argument2.equals(argument1);
            }
        }, "nine", FastList.\<String>newList()));

        Assert.assertEquals(FastList.newListWith("zero"), map1.selectWith(new Predicate2\<String, String>()
        {
            public boolean accept(String argument1, String argument2)
            {
                return argument1.endsWith(argument2);
            }
        }, "o", FastList.\<String>newList()));
    }

    @Test
    public void selectInstancesOf()
    {
        Mutable<name>ObjectMap\<Number> numbers = this.\<Number>newWithKeysValues(<(literal.(type))("0")>, 0, <(literal.(type))("1")>, 1.0, <(literal.(type))("5")>, 5.0);

        Assert.assertEquals(FastList.newListWith(0), numbers.selectInstancesOf(Integer.class));
        Assert.assertEquals(FastList.newListWith(1.0, 5.0), numbers.selectInstancesOf(Double.class));
    }

    @Test
    public void collect()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Assert.assertEquals(FastList.newListWith("ZERO", "ONE", "NINE"), map1.collect(new Function\<String, String>()
        {
            public String valueOf(String object)
            {
                return object.toUpperCase();
            }
        }));

        Assert.assertEquals(FastList.newListWith("ZERO", "ONE", "NINE"), map1.collect(new Function\<String, String>()
        {
            public String valueOf(String object)
            {
                return object.toUpperCase();
            }
        }, FastList.\<String>newList()));
    }

    @Test
    public void collectWith()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Assert.assertEquals(FastList.newListWith("ZERO!", "ONE!", "NINE!"), map1.collectWith(new Function2\<String, String, String>()
        {
            public String value(String argument1, String argument2)
            {
                return argument1.toUpperCase() + argument2;
            }
        }, "!", FastList.\<String>newList()));
    }

    @Test
    public void collectIf()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Predicate\<String> endsWithNe = new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("ne");
            }
        };

        Assert.assertEquals(FastList.newListWith("ONE", "NINE"), map1.collectIf(endsWithNe, new Function\<String, String>()
        {
            public String valueOf(String object)
            {
                return object.toUpperCase();
            }
        }));

        Predicate\<String> endsWithO = new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("o");
            }
        };

        Assert.assertEquals(FastList.newListWith("ZERO"), map1.collectIf(endsWithO, new Function\<String, String>()
        {
            public String valueOf(String object)
            {
                return object.toUpperCase();
            }
        }));

        Assert.assertEquals(FastList.newListWith("ZERO"), map1.collectIf(endsWithO, new Function\<String, String>()
        {
            public String valueOf(String object)
            {
                return object.toUpperCase();
            }
        }, FastList.\<String>newList()));
    }

    @Test
    public void flatCollect()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("9")>, "nine");

        Function\<String, FastList\<Character>\> toChars = new Function\<String, FastList\<Character>\>()
        {
            public FastList\<Character> valueOf(String object)
            {
                FastList\<Character> list = FastList.newList();
                char[] chars = object.toCharArray();
                for (char aChar : chars)
                {
                    list.add(aChar);
                }
                return list;
            }
        };

        Assert.assertEquals(UnifiedSet.newSetWith('z', 'e', 'r', 'o', 'n', 'i'), map1.flatCollect(toChars).toSet());
        Assert.assertEquals(UnifiedSet.newSetWith('o', 'n', 'e', 'i'), map2.flatCollect(toChars).toSet());
        Assert.assertEquals(UnifiedSet.newSetWith('f', 'i', 'v', 'e', 'n'), map3.flatCollect(toChars).toSet());
        Assert.assertEquals(UnifiedSet.newSetWith('f', 'i', 'v', 'e', 'n'), map3.flatCollect(toChars, UnifiedSet.\<Character>newSet()));
    }

    @Test
    public void detect()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Predicate\<String> endsWithNe = new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("ne");
            }
        };

        Assert.assertTrue("one".equals(map1.detect(endsWithNe)) || "nine".equals(map1.detect(endsWithNe)));
        Assert.assertEquals("zero", map1.detect(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("o");
            }
        }));
        Assert.assertEquals("nine", map1.detect(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return "nine".equals(each);
            }
        }));
        Assert.assertNull(map1.detect(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.equals("ten");
            }
        }));
    }

    @Test
    public void detectIfNone()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Predicate\<String> endsWithNe = new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("ne");
            }
        };

        Function0\<String> ifNone = new Function0\<String>()
        {
            public String value()
            {
                return "ifNone";
            }
        };
        Assert.assertTrue("one".equals(map1.detectIfNone(endsWithNe, ifNone)) || "nine".equals(map1.detectIfNone(endsWithNe, ifNone)));
        Assert.assertEquals("zero", map1.detectIfNone(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("o");
            }
        }, ifNone));
        Assert.assertEquals("nine", map1.detectIfNone(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return "nine".equals(each);
            }
        }, ifNone));
        Assert.assertEquals("ifNone", map1.detectIfNone(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return "ten".equals(each);
            }
        }, ifNone));
    }

    @Test
    public void count()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Predicate\<String> endsWithNe = new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("ne");
            }
        };

        Verify.assertCount(2, map1, endsWithNe);
        Verify.assertCount(1, map1, new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("o");
            }
        });
        Verify.assertCount(1, map1, new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return "nine".equals(each);
            }
        });
        Verify.assertCount(0, map1, new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return "ten".equals(each);
            }
        });
    }

    @Test
    public void anySatisfy()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Predicate\<String> endsWithNe = new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("ne");
            }
        };

        Verify.assertAnySatisfy(map1, endsWithNe);
        Verify.assertAnySatisfy(map1, new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("o");
            }
        });
        Verify.assertAnySatisfy(map1, new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return "nine".equals(each);
            }
        });
        Assert.assertFalse(map1.anySatisfy(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return "ten".equals(each);
            }
        }));
    }

    @Test
    public void allSatisfy()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Predicate\<String> containsE = new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.contains("e");
            }
        };

        Assert.assertTrue(map1.allSatisfy(containsE));
        Assert.assertFalse(map1.allSatisfy(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("o");
            }
        }));
        Assert.assertFalse(map1.allSatisfy(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.contains("o");
            }
        }));
        Assert.assertFalse(map1.allSatisfy(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return "nine".equals(each);
            }
        }));
        Assert.assertFalse(map1.allSatisfy(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return "ten".equals(each);
            }
        }));
    }

    @Test
    public void noneSatisfy()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Predicate\<String> notContainE = new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return !each.contains("e");
            }
        };

        Assert.assertTrue(map1.noneSatisfy(notContainE));
        Assert.assertFalse(map1.noneSatisfy(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("o");
            }
        }));
        Assert.assertFalse(map1.noneSatisfy(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.startsWith("o");
            }
        }));
        Assert.assertFalse(map1.noneSatisfy(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.contains("o");
            }
        }));
        Assert.assertFalse(map1.noneSatisfy(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return "nine".equals(each);
            }
        }));
        Assert.assertTrue(map1.noneSatisfy(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return "ten".equals(each);
            }
        }));
    }

    @Test
    public void injectInto()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("9")>, "nine");

        Function2\<String, String, String> concat = new Function2\<String, String, String>()
        {
            public String value(String argument1, String argument2)
            {
                return argument1 + '-' + argument2;
            }
        };

        Assert.assertTrue("Start-zero-nine".equals(map1.injectInto("Start", concat))
                || "Start-nine-zero".equals(map1.injectInto("Start", concat)));
        Assert.assertTrue("Start-one-nine".equals(map2.injectInto("Start", concat))
                || "Start-nine-one".equals(map2.injectInto("Start", concat)));
        Assert.assertTrue("Start-five-nine".equals(map3.injectInto("Start", concat))
                || "Start-nine-five".equals(map3.injectInto("Start", concat)));

    }

    @Test
    public void intInjectInto()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "a", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "abc", <(literal.(type))("9")>, "abcd");

        IntObjectToIntFunction\<String> function = new IntObjectToIntFunction\<String>()
        {
            public int intValueOf(int intParameter, String objectParameter)
            {
                return intParameter + objectParameter.length();
            }
        };
        Assert.assertEquals(6, map1.injectInto(1, function));
        Assert.assertEquals(7, map2.injectInto(1, function));
        Assert.assertEquals(8, map3.injectInto(1, function));
    }

    @Test
    public void longInjectInto()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "a", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "abc", <(literal.(type))("9")>, "abcd");

        LongObjectToLongFunction\<String> function = new LongObjectToLongFunction\<String>()
        {
            public long longValueOf(long longParameter, String objectParameter)
            {
                return longParameter + objectParameter.length();
            }
        };
        Assert.assertEquals(6L, map1.injectInto(1L, function));
        Assert.assertEquals(7L, map2.injectInto(1L, function));
        Assert.assertEquals(8L, map3.injectInto(1L, function));
    }

    @Test
    public void floatInjectInto()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "a", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "abc", <(literal.(type))("9")>, "abcd");

        FloatObjectToFloatFunction\<String> function = new FloatObjectToFloatFunction\<String>()
        {
            public float floatValueOf(float floatParameter, String objectParameter)
            {
                return floatParameter + objectParameter.length();
            }
        };
        Assert.assertEquals(6.0f, map1.injectInto(1.0f, function), 0.0);
        Assert.assertEquals(7.0f, map2.injectInto(1.0f, function), 0.0);
        Assert.assertEquals(8.0f, map3.injectInto(1.0f, function), 0.0);
    }

    @Test
    public void doubleInjectInto()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "a", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "abc", <(literal.(type))("9")>, "abcd");

        DoubleObjectToDoubleFunction\<String> function = new DoubleObjectToDoubleFunction\<String>()
        {
            public double doubleValueOf(double doubleParameter, String objectParameter)
            {
                return doubleParameter + objectParameter.length();
            }
        };
        Assert.assertEquals(6.0, map1.injectInto(1.0, function), 0.0);
        Assert.assertEquals(7.0, map2.injectInto(1.0, function), 0.0);
        Assert.assertEquals(8.0, map3.injectInto(1.0, function), 0.0);
    }

    @Test
    public void toList()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("9")>, "nine");

        Assert.assertTrue(map1.toList().toString(), FastList.newListWith("zero", "nine").equals(map1.toList())
                || FastList.newListWith("nine", "zero").equals(map1.toList()));
        Assert.assertTrue(map2.toList().toString(), FastList.newListWith("one", "nine").equals(map2.toList())
                || FastList.newListWith("nine", "one").equals(map2.toList()));
        Assert.assertTrue(map3.toList().toString(), FastList.newListWith("five", "nine").equals(map3.toList())
                || FastList.newListWith("nine", "five").equals(map3.toList()));
    }

    @Test
    public void toSortedList()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("9")>, "nine");

        Assert.assertEquals(map1.toSortedList().toString(),
                FastList.newListWith("nine", "zero"), map1.toSortedList());
        Assert.assertEquals(map2.toSortedList().toString(),
                FastList.newListWith("nine", "one"), map2.toSortedList());
        Assert.assertEquals(map3.toSortedList().toString(), FastList.newListWith("five", "nine"), map3.toSortedList());

        Comparator\<String> comparator = new Comparator\<String>()
        {
            public int compare(String o1, String o2)
            {
                return o1.substring(1).compareTo(o2.substring(1));
            }
        };
        Assert.assertEquals(map1.toSortedList(comparator).toString(),
                FastList.newListWith("zero", "nine"), map1.toSortedList(comparator));
        Assert.assertEquals(map2.toSortedList(comparator).toString(),
                FastList.newListWith("nine", "one"), map2.toSortedList(comparator));
        Assert.assertEquals(map3.toSortedList(comparator).toString(), FastList.newListWith("nine", "five"), map3.toSortedList(comparator));

        Function\<String, String> substring = new Function\<String, String>()
        {
            public String valueOf(String object)
            {
                return object.substring(1);
            }
        };
        Assert.assertEquals(map1.toSortedListBy(substring).toString(),
                FastList.newListWith("zero", "nine"), map1.toSortedListBy(substring));
        Assert.assertEquals(map2.toSortedListBy(substring).toString(),
                FastList.newListWith("nine", "one"), map2.toSortedListBy(substring));
        Assert.assertEquals(map3.toSortedListBy(substring).toString(), FastList.newListWith("nine", "five"), map3.toSortedListBy(substring));
    }

    @Test
    public void toSet()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "zero", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "one", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("6")>, "five", <(literal.(type))("9")>, "nine");

        Assert.assertEquals(map1.toSet().toString(), UnifiedSet.newSetWith("zero", "nine"), map1.toSet());
        Assert.assertEquals(map2.toSet().toString(), UnifiedSet.newSetWith("one", "nine"), map2.toSet());
        Assert.assertEquals(map3.toSet().toString(), UnifiedSet.newSetWith("five", "nine"), map3.toSet());
    }

    @Test
    public void toSortedSet()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "zero", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "one", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("6")>, "five", <(literal.(type))("9")>, "nine");

        Assert.assertEquals(TreeSortedSet.newSetWith("nine", "zero"), map1.toSortedSet());
        Assert.assertEquals(map2.toSortedSet().toString(),
                TreeSortedSet.newSetWith("nine", "one"), map2.toSortedSet());
        Assert.assertEquals(TreeSortedSet.newSetWith("five", "nine"), map3.toSortedSet());

        Comparator\<String> comparator = new Comparator\<String>()
        {
            public int compare(String o1, String o2)
            {
                return o1.substring(1).compareTo(o2.substring(1));
            }
        };
        Assert.assertEquals(TreeSortedSet.newSetWith("zero", "nine"), map1.toSortedSet(comparator));
        Assert.assertEquals(map2.toSortedSet(comparator).toString(),
                TreeSortedSet.newSetWith("nine", "one"), map2.toSortedSet(comparator));
        Assert.assertEquals(TreeSortedSet.newSetWith("nine", "five"), map3.toSortedSet(comparator));

        Function\<String, String> substring = new Function\<String, String>()
        {
            public String valueOf(String object)
            {
                return object.substring(1);
            }
        };
        Assert.assertEquals(TreeSortedSet.newSetWith("zero", "nine"), map1.toSortedSetBy(substring));
        Assert.assertEquals(TreeSortedSet.newSetWith("nine", "one"), map2.toSortedSetBy(substring));
        Assert.assertEquals(map3.toSortedSetBy(substring).toString(), TreeSortedSet.newSetWith("nine", "five"), map3.toSortedSetBy(substring));
    }

    @Test
    public void toBag()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "zero", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "one", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("6")>, "five", <(literal.(type))("9")>, "nine");

        Assert.assertEquals(HashBag.newBagWith("zero", "zero", "nine"), map1.toBag());
        Assert.assertEquals(HashBag.newBagWith("one", "one", "nine"), map2.toBag());
        Assert.assertEquals(HashBag.newBagWith("five", "five", "nine"), map3.toBag());
    }

    @Test
    public void toMap()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "a", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "abc", <(literal.(type))("9")>, "abcd");

        Function\<String, Integer> keyFunction = new Function\<String, Integer>()
        {
            public Integer valueOf(String object)
            {
                return object.length();
            }
        };
        Function\<String, String> valueFunction = Functions.getPassThru();
        Assert.assertEquals(UnifiedMap.newWithKeysValues(1, "a", 4, "abcd"), map1.toMap(keyFunction, valueFunction));
        Assert.assertEquals(UnifiedMap.newWithKeysValues(2, "ab", 4, "abcd"), map2.toMap(keyFunction, valueFunction));
        Assert.assertEquals(UnifiedMap.newWithKeysValues(3, "abc", 4, "abcd"), map3.toMap(keyFunction, valueFunction));
    }

    @Test
    public void toSortedMap()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        Function\<String, Integer> keyFunction = new Function\<String, Integer>()
        {
            public Integer valueOf(String object)
            {
                return object.length();
            }
        };
        Function\<String, String> valueFunction = Functions.getPassThru();
        Assert.assertEquals(UnifiedMap.newWithKeysValues(4, "abcd", 1, "z"), map1.toSortedMap(keyFunction, valueFunction));
        Assert.assertEquals(UnifiedMap.newWithKeysValues(2, "ab", 4, "abcd"), map2.toSortedMap(keyFunction, valueFunction));
        Assert.assertEquals(UnifiedMap.newWithKeysValues(4, "abcd", 3, "zyx"), map3.toSortedMap(keyFunction, valueFunction));
        Assert.assertEquals(UnifiedMap.newWithKeysValues(4, "abcd", 3, "zyx"), map3.toSortedMap(Comparators.naturalOrder(), keyFunction, valueFunction));
    }

    @Test
    public void toArray()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        Assert.assertTrue(map1.asLazy().toString(), Arrays.equals(new String[]{"abcd", "z"}, map1.toArray())
                || Arrays.equals(new String[]{"z", "abcd"}, map1.toArray()));
        Assert.assertTrue(map2.asLazy().toString(), Arrays.equals(new String[]{"abcd", "ab"}, map2.toArray())
                || Arrays.equals(new String[]{"ab", "abcd"}, map2.toArray()));
        Assert.assertTrue(map3.asLazy().toString(), Arrays.equals(new String[]{"abcd", "zyx"}, map3.toArray())
                || Arrays.equals(new String[]{"zyx", "abcd"}, map3.toArray()));

        Assert.assertTrue(map1.asLazy().toString(), Arrays.equals(new String[]{"abcd", "z"}, map1.toArray(new String[2]))
                || Arrays.equals(new String[]{"z", "abcd"}, map1.toArray()));
        Assert.assertTrue(map2.asLazy().toString(), Arrays.equals(new String[]{"abcd", "ab"}, map2.toArray(new String[4]))
                || Arrays.equals(new String[]{"ab", "abcd"}, map2.toArray()));
        Assert.assertTrue(map3.asLazy().toString(), Arrays.equals(new String[]{"abcd", "zyx"}, map3.toArray(new String[2]))
                || Arrays.equals(new String[]{"zyx", "abcd"}, map3.toArray()));
    }

    @Test
    public void min()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        Assert.assertEquals("abcd", map1.min());
        Assert.assertEquals("ab", map2.min());
        Assert.assertEquals("abcd", map3.min());
        Assert.assertEquals("abcd", map3.min(Comparators.naturalOrder()));
    }

    @Test(expected = NoSuchElementException.class)
    public void min_throws_empty()
    {
        <name>ObjectHashMap.newMap().min();
    }

    @Test
    public void maxBy()
    {
        Mutable<name>ObjectMap\<Class\<?>\> map1 = this.newWithKeysValues(<(literal.(type))("0")>, <name>ObjectHashMapTest.class, <(literal.(type))("9")>, <name>ObjectHashMap.class);
        Mutable<name>ObjectMap\<Class\<?>\> map2 = this.newWithKeysValues(<(literal.(type))("1")>, <name>ObjectHashMapTest.class, <(literal.(type))("9")>, <name>ObjectHashMap.class);
        Mutable<name>ObjectMap\<Class\<?>\> map3 = this.newWithKeysValues(<(literal.(type))("5")>, <name>ObjectHashMap.class, <(literal.(type))("9")>, <name>ObjectHashMapTest.class);

        final Function\<Class\<?>, Integer> classNameLength = new Function\<Class\<?>, Integer>()
        {
            public Integer valueOf(Class\<?> aClass)
            {
                return aClass.getName().length();
            }
        };
        Assert.assertEquals(<name>ObjectHashMapTest.class, map1.maxBy(classNameLength));
        Assert.assertEquals(<name>ObjectHashMapTest.class, map2.maxBy(classNameLength));
        Assert.assertEquals(<name>ObjectHashMapTest.class, map3.maxBy(classNameLength));

        Verify.assertThrows(NoSuchElementException.class, new Runnable()
        {
            public void run()
            {
                <name>ObjectHashMap.\<Class\<?>\>newMap().maxBy(classNameLength);
            }
        });
    }

    @Test
    public void max()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        Assert.assertEquals("z", map1.max());
        Assert.assertEquals("abcd", map2.max());
        Assert.assertEquals("zyx", map3.max());
        Assert.assertEquals("zyx", map3.max(Comparators.naturalOrder()));
    }

    @Test(expected = NoSuchElementException.class)
    public void max_throws_empty()
    {
        <name>ObjectHashMap.newMap().max();
    }

    @Test
    public void minBy()
    {
        Mutable<name>ObjectMap\<Class\<?>\> map1 = this.newWithKeysValues(<(literal.(type))("0")>, <name>ObjectHashMapTest.class, <(literal.(type))("9")>, <name>ObjectHashMap.class);
        Mutable<name>ObjectMap\<Class\<?>\> map2 = this.newWithKeysValues(<(literal.(type))("1")>, <name>ObjectHashMapTest.class, <(literal.(type))("9")>, <name>ObjectHashMap.class);
        Mutable<name>ObjectMap\<Class\<?>\> map3 = this.newWithKeysValues(<(literal.(type))("5")>, <name>ObjectHashMap.class, <(literal.(type))("9")>, <name>ObjectHashMapTest.class);

        final Function\<Class\<?>, Integer> classNameLength = new Function\<Class\<?>, Integer>()
        {
            public Integer valueOf(Class\<?> object)
            {
                return object.getName().length();
            }
        };
        Assert.assertEquals(<name>ObjectHashMap.class, map1.minBy(classNameLength));
        Assert.assertEquals(<name>ObjectHashMap.class, map2.minBy(classNameLength));
        Assert.assertEquals(<name>ObjectHashMap.class, map3.minBy(classNameLength));

        Verify.assertThrows(NoSuchElementException.class, new Runnable()
        {
            public void run()
            {
                <name>ObjectHashMap.\<Class\<?>\>newMap().minBy(classNameLength);
            }
        });
    }

    @Test
    public void sumOfInt()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        IntFunction\<String> function = new IntFunction\<String>()
        {
            public int intValueOf(String anObject)
            {
                return anObject.length();
            }
        };
        Assert.assertEquals(5L, map1.sumOfInt(function));
        Assert.assertEquals(6L, map2.sumOfInt(function));
        Assert.assertEquals(7L, map3.sumOfInt(function));
    }

    @Test
    public void sumOfLong()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        LongFunction\<String> function = new LongFunction\<String>()
        {
            public long longValueOf(String anObject)
            {
                return anObject.length();
            }
        };
        Assert.assertEquals(5L, map1.sumOfLong(function));
        Assert.assertEquals(6L, map2.sumOfLong(function));
        Assert.assertEquals(7L, map3.sumOfLong(function));
    }

    @Test
    public void sumOfDouble()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        DoubleFunction\<String> function = new DoubleFunction\<String>()
        {
            public double doubleValueOf(String anObject)
            {
                return anObject.length();
            }
        };
        Assert.assertEquals(5.0, map1.sumOfDouble(function), 0.0);
        Assert.assertEquals(6.0, map2.sumOfDouble(function), 0.0);
        Assert.assertEquals(7.0, map3.sumOfDouble(function), 0.0);
    }

    @Test
    public void sumOfFloat()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "z", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "ab", <(literal.(type))("9")>, "abcd");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("5")>, "zyx", <(literal.(type))("9")>, "abcd");

        FloatFunction\<String> function = new FloatFunction\<String>()
        {
            public float floatValueOf(String anObject)
            {
                return anObject.length();
            }
        };
        Assert.assertEquals(5.0, map1.sumOfFloat(function), 0.0);
        Assert.assertEquals(6.0, map2.sumOfFloat(function), 0.0);
        Assert.assertEquals(7.0, map3.sumOfFloat(function), 0.0);
    }

    @Test
    public void withoutKey()
    {
        Mutable<name>ObjectMap\<String> actual = this.map.withoutKey(<(literal.(type))("55")>);
        Assert.assertSame(this.map, actual);
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("31")>, "thirtyOne", <(literal.(type))("32")>, "thirtyTwo"), actual);
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("31")>, "thirtyOne", <(literal.(type))("32")>, "thirtyTwo"), this.map.withoutKey(<(literal.(type))("0")>));
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("32")>, "thirtyTwo"), this.map.withoutKey(<(literal.(type))("31")>));
        Assert.assertEquals(<name>ObjectHashMap.newMap(), this.map.withoutKey(<(literal.(type))("32")>));
        Assert.assertEquals(<name>ObjectHashMap.newMap(), this.map.withoutKey(<(literal.(type))("1")>));
    }

    @Test
    public void withoutAllKeys()
    {
        Mutable<name>ObjectMap\<String> actual = this.map.withoutAllKeys(<name>ArrayList.newListWith(<(literal.(type))("55")>, <(literal.(type))("1")>));
        Assert.assertSame(this.map, actual);
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("31")>, "thirtyOne", <(literal.(type))("32")>, "thirtyTwo"), actual);
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("32")>, "thirtyTwo"), this.map.withoutAllKeys(<name>ArrayList.newListWith(<(literal.(type))("0")>, <(literal.(type))("31")>)));
        Assert.assertEquals(<name>ObjectHashMap.newMap(), this.map.withoutAllKeys(<name>ArrayList.newListWith(<(literal.(type))("31")>, <(literal.(type))("32")>)));
        Assert.assertEquals(<name>ObjectHashMap.newMap(), this.map.withoutAllKeys(<name>ArrayList.newListWith(<(literal.(type))("1")>)));
    }

    @Test
    public void reject()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");
        Mutable<name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("5")>, "five", <(literal.(type))("9")>, "nine");

        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine"), map1.reject(new <name>ObjectPredicate\<String>()
        {
            public boolean accept(<type> value, String object)
            {
                return (value % 2) == 0;
            }
        }));

        <name>ObjectPredicate\<String> keyLessThanSeven = new <name>ObjectPredicate\<String>()
        {
            public boolean accept(<type> value, String object)
            {
                return value > 7;
            }
        };
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one"), map1.reject(keyLessThanSeven));

        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero"), map2.reject(keyLessThanSeven));

        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one"), map3.reject(keyLessThanSeven));

        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("5")>, "five"), map4.reject(keyLessThanSeven));

        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine"), map1.reject(new <name>ObjectPredicate\<String>()
        {
            public boolean accept(<type> value, String object)
            {
                return !object.endsWith("ne");
            }
        }));

        RichIterable\<String> actual1 = map1.reject(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return !each.endsWith("ne");
            }
        });
        Assert.assertTrue(FastList.newListWith("one", "nine").equals(actual1) || FastList.newListWith("nine", "one").equals(actual1));

        Assert.assertEquals(FastList.newListWith("nine"), map1.reject(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return !"nine".equals(each);
            }
        }));

        Assert.assertEquals(FastList.newListWith("zero"), map1.reject(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return !each.endsWith("o");
            }
        }));

        Assert.assertEquals(FastList.newListWith("nine"), map1.reject(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return !"nine".equals(each);
            }
        }, FastList.\<String>newList()));

        Assert.assertEquals(FastList.newListWith("one", "nine"), map1.reject(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return !each.endsWith("ne");
            }
        }, FastList.\<String>newList()));

        Assert.assertEquals(FastList.newListWith("zero"), map1.reject(new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return !each.endsWith("o");
            }
        }, FastList.\<String>newList()));
    }

    @Test
    public void rejectWith()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Assert.assertEquals(FastList.newListWith("one", "nine"), map1.rejectWith(new Predicate2\<String, String>()
        {
            public boolean accept(String argument1, String argument2)
            {
                return !argument1.endsWith(argument2);
            }
        }, "ne", FastList.\<String>newList()));

        Assert.assertEquals(FastList.newListWith("nine"), map1.rejectWith(new Predicate2\<String, String>()
        {
            public boolean accept(String argument1, String argument2)
            {
                return !argument2.equals(argument1);
            }
        }, "nine", FastList.\<String>newList()));

        Assert.assertEquals(FastList.newListWith("zero"), map1.rejectWith(new Predicate2\<String, String>()
        {
            public boolean accept(String argument1, String argument2)
            {
                return !argument1.endsWith(argument2);
            }
        }, "o", FastList.\<String>newList()));
    }

    @Test
    public void partition()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("9")>, "nine");

        Predicate\<String> endsWithNe = new Predicate\<String>()
        {
            public boolean accept(String each)
            {
                return each.endsWith("ne");
            }
        };

        PartitionIterable\<String> partition = map1.partition(endsWithNe);
        Assert.assertTrue(FastList.newListWith("one", "nine").equals(partition.getSelected()) || FastList.newListWith("nine", "one").equals(partition.getSelected()));
        Assert.assertEquals(FastList.newListWith("zero"), partition.getRejected());
    }

    @Test
    public void get()
    {
        Assert.assertEquals("zero", this.map.get(<(literal.(type))("0")>));
        Assert.assertEquals("thirtyOne", this.map.get(<(literal.(type))("31")>));
        Assert.assertEquals("thirtyTwo", this.map.get(<(literal.(type))("32")>));

        Assert.assertNull(this.map.get(<(literal.(type))("1")>));
        Assert.assertNull(this.map.get(<(literal.(type))("33")>));

        Assert.assertEquals("zero", this.map.put(<(literal.(type))("0")>, "one"));
        Assert.assertEquals("one", this.map.get(<(literal.(type))("0")>));

        Assert.assertNull(this.map.put(<(literal.(type))("5")>, "five"));
        Assert.assertEquals("five", this.map.get(<(literal.(type))("5")>));

        Assert.assertNull(this.map.put(<(literal.(type))("35")>, "thirtyFive"));
        Assert.assertEquals("thirtyFive", this.map.get(<(literal.(type))("35")>));

        Assert.assertNull(this.map.put(<(literal.(type))("6")>, null));
        Assert.assertNull(this.map.get(<(literal.(type))("6")>));

        Assert.assertNull(this.map.put(<(literal.(type))("36")>, null));
        Assert.assertNull(this.map.get(<(literal.(type))("36")>));

        Mutable<name>ObjectMap\<Object> emptyMap = this.getEmptyMap();
        Assert.assertNull(emptyMap.get(<(literal.(type))("0")>));
        Assert.assertNull(emptyMap.get(<(literal.(type))("1")>));
        Assert.assertNull(emptyMap.get(<(literal.(type))("33")>));
    }

    @Test
    public void getIfAbsent()
    {
        Function0\<String> ifAbsent = new Function0\<String>()
        {
            public String value()
            {
                return "ifAbsent";
            }
        };

        Assert.assertEquals("zero", this.map.getIfAbsent(<(literal.(type))("0")>, ifAbsent));
        Assert.assertEquals("thirtyOne", this.map.getIfAbsent(<(literal.(type))("31")>, ifAbsent));
        Assert.assertEquals("thirtyTwo", this.map.getIfAbsent(<(literal.(type))("32")>, ifAbsent));

        Assert.assertEquals("ifAbsent", this.map.getIfAbsent(<(literal.(type))("1")>, ifAbsent));
        Assert.assertEquals("ifAbsent", this.map.getIfAbsent(<(literal.(type))("33")>, ifAbsent));

        Assert.assertEquals("zero", this.map.put(<(literal.(type))("0")>, "one"));
        Assert.assertEquals("one", this.map.getIfAbsent(<(literal.(type))("0")>, ifAbsent));

        Assert.assertNull(this.map.put(<(literal.(type))("5")>, "five"));
        Assert.assertEquals("five", this.map.getIfAbsent(<(literal.(type))("5")>, ifAbsent));

        Assert.assertNull(this.map.put(<(literal.(type))("35")>, "thirtyFive"));
        Assert.assertEquals("thirtyFive", this.map.getIfAbsent(<(literal.(type))("35")>, ifAbsent));

        Assert.assertNull(this.map.put(<(literal.(type))("6")>, null));
        Assert.assertNull(this.map.getIfAbsent(<(literal.(type))("6")>, ifAbsent));

        Assert.assertNull(this.map.put(<(literal.(type))("36")>, null));
        Assert.assertNull(this.map.getIfAbsent(<(literal.(type))("36")>, ifAbsent));

        Mutable<name>ObjectMap\<Object> emptyMap = this.getEmptyMap();
        Assert.assertEquals("ifAbsent", emptyMap.getIfAbsent(<(literal.(type))("0")>, ifAbsent));
        Assert.assertEquals("ifAbsent", emptyMap.getIfAbsent(<(literal.(type))("1")>, ifAbsent));
        Assert.assertEquals("ifAbsent", emptyMap.getIfAbsent(<(literal.(type))("33")>, ifAbsent));
    }

    @Test
    public void containsKey()
    {
        Assert.assertTrue(this.map.containsKey(<(literal.(type))("0")>));
        Assert.assertTrue(this.map.containsKey(<(literal.(type))("31")>));
        Assert.assertTrue(this.map.containsKey(<(literal.(type))("32")>));
        Assert.assertFalse(this.map.containsKey(<(literal.(type))("1")>));
        Assert.assertFalse(this.map.containsKey(<(literal.(type))("5")>));
        Assert.assertFalse(this.map.containsKey(<(literal.(type))("35")>));

        Assert.assertEquals("zero", this.map.removeKey(<(literal.(type))("0")>));
        Assert.assertFalse(this.map.containsKey(<(literal.(type))("0")>));
        Assert.assertEquals("thirtyOne", this.map.removeKey(<(literal.(type))("31")>));
        Assert.assertFalse(this.map.containsKey(<(literal.(type))("31")>));
        Assert.assertEquals("thirtyTwo", this.map.removeKey(<(literal.(type))("32")>));
        Assert.assertFalse(this.map.containsKey(<(literal.(type))("32")>));
    }

    @Test
    public void containsValue()
    {
        Assert.assertFalse(this.map.containsValue(null));
        Assert.assertTrue(this.map.containsValue("zero"));
        Assert.assertTrue(this.map.containsValue("thirtyOne"));
        Assert.assertTrue(this.map.containsValue("thirtyTwo"));

        Assert.assertNull(this.map.put(<(literal.(type))("5")>, null));
        Assert.assertTrue(this.map.containsValue(null));

        Assert.assertNull(this.map.removeKey(<(literal.(type))("5")>));
        Assert.assertNull(this.map.put(<(literal.(type))("35")>, null));
        Assert.assertTrue(this.map.containsValue(null));
    }

    @Test
    public void forEachValue()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");
        final String[] concat = {"", "", "", ""};

        map1.forEachValue(new Procedure\<String>()
        {
            public void value(String each)
            {
                concat[0] += each;
            }
        });
        map2.forEachValue(new Procedure\<String>()
        {
            public void value(String each)
            {
                concat[1] += each;
            }
        });
        map3.forEachValue(new Procedure\<String>()
        {
            public void value(String each)
            {
                concat[2] += each;
            }
        });
        map4.forEachValue(new Procedure\<String>()
        {
            public void value(String each)
            {
                concat[3] += each;
            }
        });

        Assert.assertTrue(concat[0], "onefive".equals(concat[0]) || "fiveone".equals(concat[0]));
        Assert.assertTrue(concat[1], "onezero".equals(concat[1]) || "zeroone".equals(concat[1]));
        Assert.assertTrue(concat[2], "twofive".equals(concat[2]) || "fivetwo".equals(concat[2]));
        Assert.assertTrue(concat[3], "zerofive".equals(concat[3]) || "fivezero".equals(concat[3]));
    }

    @Test
    public void forEachKey()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");
        final <wideType.(type)>[] sum = new <wideType.(type)>[4];

        map1.forEachKey(new <name>Procedure()
        {
            public void value(<type> each)
            {
                sum[0] += each;
            }
        });
        map2.forEachKey(new <name>Procedure()
        {
            public void value(<type> each)
            {
                sum[1] += each;
            }
        });
        map3.forEachKey(new <name>Procedure()
        {
            public void value(<type> each)
            {
                sum[2] += each;
            }
        });
        map4.forEachKey(new <name>Procedure()
        {
            public void value(<type> each)
            {
                sum[3] += each;
            }
        });

        Assert.assertEquals(<(wideLiteral.(type))("6")>, sum[0]<(wideDelta.(type))>);
        Assert.assertEquals(<(wideLiteral.(type))("1")>, sum[1]<(wideDelta.(type))>);
        Assert.assertEquals(<(wideLiteral.(type))("7")>, sum[2]<(wideDelta.(type))>);
        Assert.assertEquals(<(wideLiteral.(type))("5")>, sum[3]<(wideDelta.(type))>);
    }

    @Test
    public void forEachKeyValue()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");
        final String[] concat = {"", "", "", ""};

        map1.forEachKeyValue(new <name>ObjectProcedure\<String>()
        {
            public void value(<type> each, String parameter)
            {
                concat[0] += each;
                concat[0] += parameter;
            }
        });
        map2.forEachKeyValue(new <name>ObjectProcedure\<String>()
        {
            public void value(<type> each, String parameter)
            {
                concat[1] += each;
                concat[1] += parameter;
            }
        });
        map3.forEachKeyValue(new <name>ObjectProcedure\<String>()
        {
            public void value(<type> each, String parameter)
            {
                concat[2] += each;
                concat[2] += parameter;
            }
        });
        map4.forEachKeyValue(new <name>ObjectProcedure\<String>()
        {
            public void value(<type> each, String parameter)
            {
                concat[3] += each;
                concat[3] += parameter;
            }
        });

        Assert.assertTrue(concat[0], "<(toStringLiteral.(type))("1")>one<(toStringLiteral.(type))("5")>five".equals(concat[0]) || "<(toStringLiteral.(type))("5")>five<(toStringLiteral.(type))("1")>one".equals(concat[0]));
        Assert.assertTrue(concat[1], "<(toStringLiteral.(type))("1")>one<(toStringLiteral.(type))("0")>zero".equals(concat[1]) || "<(toStringLiteral.(type))("0")>zero<(toStringLiteral.(type))("1")>one".equals(concat[1]));
        Assert.assertTrue(concat[2], "<(toStringLiteral.(type))("2")>two<(toStringLiteral.(type))("5")>five".equals(concat[2]) || "<(toStringLiteral.(type))("5")>five<(toStringLiteral.(type))("2")>two".equals(concat[2]));
        Assert.assertTrue(concat[3], "<(toStringLiteral.(type))("0")>zero<(toStringLiteral.(type))("5")>five".equals(concat[3]) || "<(toStringLiteral.(type))("5")>five<(toStringLiteral.(type))("0")>zero".equals(concat[3]));
    }

    @Test
    public void size()
    {
        Assert.assertEquals(0, this.getEmptyMap().size());
        Assert.assertEquals(1, this.getEmptyMap().withKeyValue(<(literal.(type))("0")>, "zero").size());
        Assert.assertEquals(1, this.getEmptyMap().withKeyValue(<(literal.(type))("1")>, "one").size());

        Mutable<name>ObjectMap\<String> hashMap1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        Assert.assertEquals(2, hashMap1.size());
        hashMap1.removeKey(<(literal.(type))("1")>);
        Assert.assertEquals(1, hashMap1.size());
        hashMap1.removeKey(<(literal.(type))("0")>);
        Assert.assertEquals(0, hashMap1.size());

        Assert.assertEquals(2, <name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five").size());
        Assert.assertEquals(2, <name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five").size());
        Assert.assertEquals(3, <name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five").size());
        Assert.assertEquals(2, <name>ObjectHashMap.newWithKeysValues(<(literal.(type))("6")>, "six", <(literal.(type))("5")>, "five").size());

        Mutable<name>ObjectMap\<String> hashMap = this.newWithKeysValues(<(literal.(type))("6")>, "six", <(literal.(type))("5")>, "five");
        hashMap.removeKey(<(literal.(type))("5")>);
        Assert.assertEquals(1, hashMap.size());
    }

    @Test
    public void isEmpty()
    {
        Assert.assertTrue(<name>ObjectHashMap.newMap().isEmpty());
        Assert.assertFalse(this.map.isEmpty());
        Assert.assertFalse(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one").isEmpty());
        Assert.assertFalse(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero").isEmpty());
        Assert.assertFalse(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("50")>, "fifty").isEmpty());
    }

    @Test
    public void notEmpty()
    {
        Assert.assertFalse(<name>ObjectHashMap.newMap().notEmpty());
        Assert.assertTrue(this.map.notEmpty());
        Assert.assertTrue(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one").notEmpty());
        Assert.assertTrue(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero").notEmpty());
        Assert.assertTrue(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("50")>, "fifty").notEmpty());
    }

    @Test
    public void getFirst()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");

        Assert.assertTrue(map1.getFirst(), "one".equals(map1.getFirst()) || "five".equals(map1.getFirst()));
        Assert.assertTrue(map2.getFirst(), "one".equals(map2.getFirst()) || "zero".equals(map2.getFirst()));
        Assert.assertTrue(map3.getFirst(), "two".equals(map3.getFirst()) || "five".equals(map3.getFirst()));
        Assert.assertTrue(map4.getFirst(), "zero".equals(map4.getFirst()) || "five".equals(map4.getFirst()));
        Assert.assertNull(<name>ObjectHashMap.newMap().getFirst());
    }

    @Test
    public void getLast()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");

        Assert.assertTrue(map1.getLast(), "one".equals(map1.getLast()) || "five".equals(map1.getLast()));
        Assert.assertTrue(map2.getLast(), "one".equals(map2.getLast()) || "zero".equals(map2.getLast()));
        Assert.assertTrue(map3.getLast(), "two".equals(map3.getLast()) || "five".equals(map3.getLast()));
        Assert.assertTrue(map4.getLast(), "zero".equals(map4.getLast()) || "five".equals(map4.getLast()));
        Assert.assertEquals("zero", this.newWithKeysValues(<(literal.(type))("0")>, "zero").getLast());
        Assert.assertNull(<name>ObjectHashMap.newMap().getLast());
    }

    @Test
    public void contains()
    {
        Assert.assertFalse(this.map.contains(null));
        Assert.assertTrue(this.map.contains("zero"));
        Assert.assertTrue(this.map.contains("thirtyOne"));
        Assert.assertTrue(this.map.contains("thirtyTwo"));

        Assert.assertNull(this.map.put(<(literal.(type))("1")>, null));
        Assert.assertTrue(this.map.contains(null));

        Assert.assertNull(this.map.removeKey(<(literal.(type))("5")>));
        Assert.assertNull(this.map.put(<(literal.(type))("35")>, null));
        Assert.assertTrue(this.map.contains(null));
    }

    @Test
    public void containsAllIterable()
    {
        Assert.assertTrue(this.map.containsAllIterable(FastList.newListWith("zero", "thirtyOne")));
        Assert.assertTrue(this.map.containsAllIterable(FastList.newListWith("zero", "thirtyOne", "thirtyTwo")));
        Assert.assertFalse(this.map.containsAllIterable(FastList.newListWith("zero", "one", "thirtyTwo")));
        Assert.assertFalse(this.map.containsAllIterable(FastList.newListWith("two", "one", "nine")));
    }

    @Test
    public void containsAll()
    {
        Assert.assertTrue(this.map.containsAll(FastList.newListWith("zero", "thirtyOne")));
        Assert.assertTrue(this.map.containsAll(FastList.newListWith("zero", "thirtyOne", "thirtyTwo")));
        Assert.assertFalse(this.map.containsAll(FastList.newListWith("zero", "one", "thirtyTwo")));
        Assert.assertFalse(this.map.containsAll(FastList.newListWith("two", "one", "nine")));
    }

    @Test
    public void containsAllArguments()
    {
        Assert.assertTrue(this.map.containsAllArguments("zero", "thirtyOne"));
        Assert.assertTrue(this.map.containsAllArguments("zero", "thirtyOne", "thirtyTwo"));
        Assert.assertFalse(this.map.containsAllArguments("zero", "one", "thirtyTwo"));
        Assert.assertFalse(this.map.containsAllArguments("two", "one", "nine"));
    }

    @Test
    public void testEquals()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("32")>, "thirtyTwo", <(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "two", <(literal.(type))("32")>, "thirtyTwo");
        Mutable<name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "one", <(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo");
        Mutable<name>ObjectMap\<String> map5 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyThree");
        Mutable<name>ObjectMap\<String> map6 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo");
        Mutable<name>ObjectMap\<String> map7 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("32")>, "thirtyTwo");
        Mutable<name>ObjectMap\<String> map8 = this.newWithKeysValues(<(literal.(type))("50")>, "zero", <(literal.(type))("60")>, "one", <(literal.(type))("70")>, "thirtyThree");
        Mutable<name>ObjectMap\<String> map9 = this.newWithKeysValues(<(literal.(type))("50")>, "zero", <(literal.(type))("60")>, "one");

        Verify.assertEqualsAndHashCode(map1, map2);
        Verify.assertPostSerializedEqualsAndHashCode(map1);
        Verify.assertPostSerializedEqualsAndHashCode(map6);
        Verify.assertPostSerializedEqualsAndHashCode(map7);
        Verify.assertPostSerializedEqualsAndHashCode(map8);
        Verify.assertPostSerializedEqualsAndHashCode(<name>ObjectHashMap.newMap());
        Verify.assertEqualsAndHashCode(map1, map2);
        Assert.assertNotEquals(map1, map3);
        Assert.assertNotEquals(map1, map4);
        Assert.assertNotEquals(map1, map5);
        Assert.assertNotEquals(map1, map6);
        Assert.assertNotEquals(map1, map7);
        Assert.assertNotEquals(map8, map5);
        Assert.assertNotEquals(map9, map8);
        Assert.assertNotEquals(this.newWithKeysValues(<(literal.(type))("0")>, null), this.newWithKeysValues(<(literal.(type))("6")>, ""));
        Assert.assertNotEquals(this.newWithKeysValues(<(literal.(type))("5")>, null), this.newWithKeysValues(<(literal.(type))("6")>, ""));
    }

    @Test
    public void testHashCode()
    {
        Assert.assertEquals(UnifiedMap.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo").hashCode(), this.newWithKeysValues(<(literal.(type))("32")>, "thirtyTwo", <(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one").hashCode());
        Assert.assertEquals(UnifiedMap.newWithKeysValues(<(literal.(type))("0")>, null, <(literal.(type))("1")>, null).hashCode(), this.newWithKeysValues(<(literal.(type))("0")>, null, <(literal.(type))("1")>, null).hashCode());
        Assert.assertEquals(UnifiedMap.newWithKeysValues(<(literal.(type))("50")>, "zero", <(literal.(type))("60")>, "one", <(literal.(type))("70")>, "thirtyThree").hashCode(), this.newWithKeysValues(<(literal.(type))("50")>, "zero", <(literal.(type))("60")>, "one", <(literal.(type))("70")>, "thirtyThree").hashCode());
        Assert.assertEquals(UnifiedMap.newWithKeysValues(<(literal.(type))("50")>, null, <(literal.(type))("60")>, null).hashCode(), this.newWithKeysValues(<(literal.(type))("50")>, null, <(literal.(type))("60")>, null).hashCode());
        Assert.assertEquals(UnifiedMap.newMap().hashCode(), this.getEmptyMap().hashCode());
    }

    @Test
    public void testToString()
    {
        Assert.assertEquals("[]", this.getEmptyMap().toString());
        Assert.assertEquals("[<(toStringLiteral.(type))("0")>=zero]", this.newWithKeysValues(<(literal.(type))("0")>, "zero").toString());
        Assert.assertEquals("[<(toStringLiteral.(type))("1")>=one]", this.newWithKeysValues(<(literal.(type))("1")>, "one").toString());
        Assert.assertEquals("[<(toStringLiteral.(type))("5")>=five]", this.newWithKeysValues(<(literal.(type))("5")>, "five").toString());

        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one");
        Assert.assertTrue(
                map1.toString(),
                "[<(toStringLiteral.(type))("0")>=zero, <(toStringLiteral.(type))("1")>=one]".equals(map1.toString())
                        || "[<(toStringLiteral.(type))("1")>=one, <(toStringLiteral.(type))("0")>=zero]".equals(map1.toString()));

        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo");
        Assert.assertTrue(
                map2.toString(),
                "[<(toStringLiteral.(type))("1")>=one, <(toStringLiteral.(type))("32")>=thirtyTwo]".equals(map2.toString())
                        || "[<(toStringLiteral.(type))("32")>=thirtyTwo, <(toStringLiteral.(type))("1")>=one]".equals(map2.toString()));

        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("32")>, "thirtyTwo");
        Assert.assertTrue(
                map3.toString(),
                "[<(toStringLiteral.(type))("0")>=zero, <(toStringLiteral.(type))("32")>=thirtyTwo]".equals(map3.toString())
                        || "[<(toStringLiteral.(type))("32")>=thirtyTwo, <(toStringLiteral.(type))("0")>=zero]".equals(map3.toString()));

        Mutable<name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("32")>, "thirtyTwo", <(literal.(type))("33")>, "thirtyThree");
        Assert.assertTrue(
                map4.toString(),
                "[<(toStringLiteral.(type))("32")>=thirtyTwo, <(toStringLiteral.(type))("33")>=thirtyThree]".equals(map4.toString())
                        || "[<(toStringLiteral.(type))("33")>=thirtyThree, <(toStringLiteral.(type))("32")>=thirtyTwo]".equals(map4.toString()));

    }

    @Test
    public void zip()
    {
        RichIterable\<Pair\<String, Integer>\> zip1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five")
                .zip(FastList.newListWith(0, 5, 6));
        RichIterable\<Pair\<String, Integer>\> zip2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five")
                .zip(FastList.newListWith(1));
        RichIterable\<Pair\<String, Integer>\> zip3 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five")
                .zip(FastList.newListWith(1), FastList.\<Pair\<String, Integer>\>newList());
        Assert.assertTrue(FastList.newListWith(Tuples.pair("zero", 0), Tuples.pair("five", 5)).equals(zip1)
                || FastList.newListWith(Tuples.pair("five", 5), Tuples.pair("zero", 0)).equals(zip1));
        Assert.assertTrue(FastList.newListWith(Tuples.pair("one", 1)).equals(zip2)
                || FastList.newListWith(Tuples.pair("five", 1)).equals(zip2));
        Assert.assertTrue(FastList.newListWith(Tuples.pair("one", 1)).equals(zip3)
                || FastList.newListWith(Tuples.pair("five", 1)).equals(zip3));
    }

    @Test
    public void zipWithIndex()
    {
        RichIterable\<Pair\<String, Integer>\> zip1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five")
                .zipWithIndex();
        RichIterable\<Pair\<String, Integer>\> zip2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five")
                .zipWithIndex();
        RichIterable\<Pair\<String, Integer>\> zip3 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five")
                .zipWithIndex(FastList.\<Pair\<String, Integer>\>newList());
        Assert.assertTrue(FastList.newListWith(Tuples.pair("zero", 0), Tuples.pair("five", 1)).equals(zip1)
                || FastList.newListWith(Tuples.pair("five", 0), Tuples.pair("zero", 1)).equals(zip1));
        Assert.assertTrue(FastList.newListWith(Tuples.pair("one", 0), Tuples.pair("five", 1)).equals(zip2)
                || FastList.newListWith(Tuples.pair("five", 0), Tuples.pair("one", 1)).equals(zip2));
        Assert.assertTrue(FastList.newListWith(Tuples.pair("one", 0), Tuples.pair("five", 1)).equals(zip3)
                || FastList.newListWith(Tuples.pair("five", 0), Tuples.pair("one", 1)).equals(zip3));
    }

    @Test
    public void chunk()
    {
        RichIterable\<RichIterable\<String>\> chunk1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five")
                .chunk(1);
        RichIterable\<RichIterable\<String>\> chunk2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five")
                .chunk(1);
        Assert.assertTrue(FastList.newListWith(FastList.newListWith("zero"), FastList.newListWith("five")).equals(chunk1)
                || FastList.newListWith(FastList.newListWith("five"), FastList.newListWith("zero")).equals(chunk1));
        Assert.assertTrue(FastList.newListWith(FastList.newListWith("one"), FastList.newListWith("five")).equals(chunk2)
                || FastList.newListWith(FastList.newListWith("five"), FastList.newListWith("one")).equals(chunk2));
    }

    @Test(expected = IllegalArgumentException.class)
    public void chunk_throws_negative_size()
    {
        this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five")
                .chunk(-1);
    }

    @Test(expected = IllegalArgumentException.class)
    public void chunk_throws_zero_size()
    {
        this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five")
                .chunk(0);
    }

    @Test
    public void aggregateInPlaceBy()
    {
        Function0\<AtomicInteger> valueCreator = new Function0\<AtomicInteger>()
        {
            public AtomicInteger value()
            {
                return new AtomicInteger(0);
            }
        };
        Procedure2\<AtomicInteger, Integer> sumAggregator = new Procedure2\<AtomicInteger, Integer>()
        {
            public void value(AtomicInteger aggregate, Integer value)
            {
                aggregate.addAndGet(value);
            }
        };
        Mutable<name>ObjectMap\<Integer> collection = this.newWithKeysValues(<(literal.(type))("1")>, 1, <(literal.(type))("2")>, 2, <(literal.(type))("3")>, 3);
        MapIterable\<String, AtomicInteger> aggregation = collection.aggregateInPlaceBy(Functions.getToString(), valueCreator, sumAggregator);
        Assert.assertEquals(1, aggregation.get("1").intValue());
        Assert.assertEquals(2, aggregation.get("2").intValue());
        Assert.assertEquals(3, aggregation.get("3").intValue());
    }

    @Test
    public void aggregateBy()
    {
        Function0\<Integer> valueCreator = new Function0\<Integer>()
        {
            public Integer value()
            {
                return Integer.valueOf(0);
            }
        };
        Function2\<Integer, Integer, Integer> sumAggregator = new Function2\<Integer, Integer, Integer>()
        {
            public Integer value(Integer aggregate, Integer value)
            {
                return aggregate + value;
            }
        };
        Mutable<name>ObjectMap\<Integer> collection = this.newWithKeysValues(<(literal.(type))("1")>, 1, <(literal.(type))("2")>, 2, <(literal.(type))("3")>, 3);
        MapIterable\<String, Integer> aggregation = collection.aggregateBy(Functions.getToString(), valueCreator, sumAggregator);
        Assert.assertEquals(1, aggregation.get("1").intValue());
        Assert.assertEquals(2, aggregation.get("2").intValue());
        Assert.assertEquals(3, aggregation.get("3").intValue());
    }

    @Test
    public void groupBy()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("3")>, "three");

        FastListMultimap\<Character, String> expected1 = FastListMultimap.newMultimap(Tuples.pair('z', "zero")
                , Tuples.pair('o', "one"));
        FastListMultimap\<Character, String> expected2 = FastListMultimap.newMultimap(Tuples.pair('t', "two")
                , Tuples.pair('t', "three"));

        Function\<String, Character> firstChar = new Function\<String, Character>()
        {
            public Character valueOf(String object)
            {
                return object.charAt(0);
            }
        };

        final Multimap\<Character, String> actual1 = map1.groupBy(firstChar);
        final Multimap\<Character, String> actual2 = map2.groupBy(firstChar);
        final Multimap\<Character, String> actual3 = map2.groupBy(firstChar, FastListMultimap.\<Character, String>newMultimap());

        Verify.assertSize(expected1.size(), actual1);
        expected1.forEachKeyValue(new Procedure2\<Character, String>()
        {
            public void value(Character argument1, String argument2)
            {
                Assert.assertTrue(actual1.containsKeyAndValue(argument1, argument2));
            }
        });

        Verify.assertSize(expected2.size(), actual2);
        expected2.forEachKeyValue(new Procedure2\<Character, String>()
        {
            public void value(Character argument1, String argument2)
            {
                Assert.assertTrue(actual2.containsKeyAndValue(argument1, argument2));
            }
        });

        Verify.assertSize(expected2.size(), actual3);
        expected2.forEachKeyValue(new Procedure2\<Character, String>()
        {
            public void value(Character argument1, String argument2)
            {
                Assert.assertTrue(actual3.containsKeyAndValue(argument1, argument2));
            }
        });
    }

    @Test
    public void groupByEach()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");

        Function\<String, UnifiedSet\<Character>\> toChars = new Function\<String, UnifiedSet\<Character>\>()
        {
            public UnifiedSet\<Character> valueOf(String object)
            {
                UnifiedSet\<Character> list = UnifiedSet.newSet();
                char[] chars = object.toCharArray();
                for (char aChar : chars)
                {
                    list.add(aChar);
                }
                return list;
            }
        };

        FastListMultimap\<Character, String> expected = FastListMultimap.newMultimap(Tuples.pair('z', "zero"), Tuples.pair('e', "zero"), Tuples.pair('r', "zero"), Tuples.pair('o', "zero")
                , Tuples.pair('n', "nine"), Tuples.pair('i', "nine"), Tuples.pair('e', "nine"));
        final Multimap\<Character, String> actual = map1.groupByEach(toChars);
        final Multimap\<Character, String> actual1 = map1.groupByEach(toChars, FastListMultimap.\<Character, String>newMultimap());

        expected.forEachKeyValue(new Procedure2\<Character, String>()
        {
            public void value(Character argument1, String argument2)
            {
                Assert.assertTrue(actual.containsKeyAndValue(argument1, argument2));
            }
        });

        expected.forEachKeyValue(new Procedure2\<Character, String>()
        {
            public void value(Character argument1, String argument2)
            {
                Assert.assertTrue(actual1.containsKeyAndValue(argument1, argument2));
            }
        });
    }

    @Test
    public void makeString()
    {
        Assert.assertEquals("", this.getEmptyMap().makeString());
        Assert.assertEquals("<(toStringLiteral.(type))("0")>=zero", this.newWithKeysValues(<(literal.(type))("0")>, "zero").makeString());
        Assert.assertEquals("<(toStringLiteral.(type))("1")>=one", this.newWithKeysValues(<(literal.(type))("1")>, "one").makeString());
        Assert.assertEquals("<(toStringLiteral.(type))("5")>=five", this.newWithKeysValues(<(literal.(type))("5")>, "five").makeString());

        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one");
        Assert.assertTrue(
                map1.makeString(),
                "<(toStringLiteral.(type))("0")>=zero, <(toStringLiteral.(type))("1")>=one".equals(map1.makeString())
                        || "<(toStringLiteral.(type))("1")>=one, <(toStringLiteral.(type))("0")>=zero".equals(map1.makeString()));

        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo");
        Assert.assertTrue(
                map2.makeString("[", "/", "]"),
                "[<(toStringLiteral.(type))("1")>=one/<(toStringLiteral.(type))("32")>=thirtyTwo]".equals(map2.makeString("[", "/", "]"))
                        || "[<(toStringLiteral.(type))("32")>=thirtyTwo/<(toStringLiteral.(type))("1")>=one]".equals(map2.makeString("[", "/", "]")));

        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("32")>, "thirtyTwo");
        Assert.assertTrue(
                map3.makeString("~"),
                "<(toStringLiteral.(type))("0")>=zero~<(toStringLiteral.(type))("32")>=thirtyTwo".equals(map3.makeString("~"))
                        || "<(toStringLiteral.(type))("32")>=thirtyTwo~<(toStringLiteral.(type))("0")>=zero".equals(map3.makeString("~")));

        Mutable<name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("32")>, "thirtyTwo", <(literal.(type))("33")>, "thirtyThree");
        Assert.assertTrue(
                map4.makeString("[", ", ", "]"),
                "[<(toStringLiteral.(type))("32")>=thirtyTwo, <(toStringLiteral.(type))("33")>=thirtyThree]".equals(map4.makeString("[", ", ", "]"))
                        || "[<(toStringLiteral.(type))("33")>=thirtyThree, <(toStringLiteral.(type))("32")>=thirtyTwo]".equals(map4.makeString("[", ", ", "]")));
    }

    @Test
    public void appendString()
    {
        Appendable appendable = new StringBuilder();
        this.getEmptyMap().appendString(appendable);
        Assert.assertEquals("", appendable.toString());

        Appendable appendable0 = new StringBuilder();
        this.newWithKeysValues(<(literal.(type))("0")>, "zero").appendString(appendable0);
        Assert.assertEquals("<(toStringLiteral.(type))("0")>=zero", appendable0.toString());

        Appendable appendable1 = new StringBuilder();
        this.newWithKeysValues(<(literal.(type))("1")>, "one").appendString(appendable1);
        Assert.assertEquals("<(toStringLiteral.(type))("1")>=one", appendable1.toString());

        Appendable appendable2 = new StringBuilder();
        this.newWithKeysValues(<(literal.(type))("5")>, "five").appendString(appendable2);
        Assert.assertEquals("<(toStringLiteral.(type))("5")>=five", appendable2.toString());

        Appendable appendable3 = new StringBuilder();
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one");
        map1.appendString(appendable3);
        Assert.assertTrue(
                appendable3.toString(),
                "<(toStringLiteral.(type))("0")>=zero, <(toStringLiteral.(type))("1")>=one".equals(appendable3.toString())
                        || "<(toStringLiteral.(type))("1")>=one, <(toStringLiteral.(type))("0")>=zero".equals(appendable3.toString()));

        Appendable appendable4 = new StringBuilder();
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo");
        map2.appendString(appendable4, "[", "/", "]");
        Assert.assertTrue(
                appendable4.toString(),
                "[<(toStringLiteral.(type))("1")>=one/<(toStringLiteral.(type))("32")>=thirtyTwo]".equals(appendable4.toString())
                        || "[<(toStringLiteral.(type))("32")>=thirtyTwo/<(toStringLiteral.(type))("1")>=one]".equals(appendable4.toString()));

        Appendable appendable5 = new StringBuilder();
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("32")>, "thirtyTwo");
        map3.appendString(appendable5, "[", "/", "]");
        Assert.assertTrue(
                appendable5.toString(),
                "[<(toStringLiteral.(type))("1")>=one/<(toStringLiteral.(type))("32")>=thirtyTwo]".equals(appendable5.toString())
                        || "[<(toStringLiteral.(type))("32")>=thirtyTwo/<(toStringLiteral.(type))("1")>=one]".equals(appendable5.toString()));

        Appendable appendable6 = new StringBuilder();
        map3.appendString(appendable6, "/");
        Assert.assertTrue(
                appendable6.toString(),
                "<(toStringLiteral.(type))("1")>=one/<(toStringLiteral.(type))("32")>=thirtyTwo".equals(appendable6.toString())
                        || "<(toStringLiteral.(type))("32")>=thirtyTwo/<(toStringLiteral.(type))("1")>=one".equals(appendable6.toString()));
    }

    @Test
    public void withKeysValues()
    {
        Mutable<name>ObjectMap\<String> emptyMap = this.\<String>getEmptyMap();
        Mutable<name>ObjectMap\<String> hashMap = emptyMap.withKeyValue(<(literal.(type))("1")>, "one");
        Assert.assertEquals(<name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one"), hashMap);
        Assert.assertSame(emptyMap, hashMap);
    }

    @Test
    public void forEach()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");
        final String[] concat = {"", "", "", ""};

        map1.forEach(new Procedure\<String>()
        {
            public void value(String each)
            {
                concat[0] += each;
            }
        });
        map2.forEach(new Procedure\<String>()
        {
            public void value(String each)
            {
                concat[1] += each;
            }
        });
        map3.forEach(new Procedure\<String>()
        {
            public void value(String each)
            {
                concat[2] += each;
            }
        });
        map4.forEach(new Procedure\<String>()
        {
            public void value(String each)
            {
                concat[3] += each;
            }
        });

        Assert.assertTrue(concat[0], "onefive".equals(concat[0]) || "fiveone".equals(concat[0]));
        Assert.assertTrue(concat[1], "onezero".equals(concat[1]) || "zeroone".equals(concat[1]));
        Assert.assertTrue(concat[2], "twofive".equals(concat[2]) || "fivetwo".equals(concat[2]));
        Assert.assertTrue(concat[3], "zerofive".equals(concat[3]) || "fivezero".equals(concat[3]));
    }

    @Test
    public void forEachWithIndex()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");
        final String[] concat = {"", "", "", ""};

        map1.forEachWithIndex(new ObjectIntProcedure\<String>()
        {
            public void value(String each, int parameter)
            {
                concat[0] += each;
                concat[0] += parameter;
            }
        });
        map2.forEachWithIndex(new ObjectIntProcedure\<String>()
        {
            public void value(String each, int parameter)
            {
                concat[1] += each;
                concat[1] += parameter;
            }
        });
        map3.forEachWithIndex(new ObjectIntProcedure\<String>()
        {
            public void value(String each, int parameter)
            {
                concat[2] += each;
                concat[2] += parameter;
            }
        });
        map4.forEachWithIndex(new ObjectIntProcedure\<String>()
        {
            public void value(String each, int parameter)
            {
                concat[3] += each;
                concat[3] += parameter;
            }
        });

        Assert.assertTrue(concat[0], "one0five1".equals(concat[0]) || "five0one1".equals(concat[0]));
        Assert.assertTrue(concat[1], "one0zero1".equals(concat[1]) || "zero0one1".equals(concat[1]));
        Assert.assertTrue(concat[2], "two0five1".equals(concat[2]) || "five0two1".equals(concat[2]));
        Assert.assertTrue(concat[3], "zero0five1".equals(concat[3]) || "five0zero1".equals(concat[3]));
    }

    @Test
    public void forEachWith()
    {
        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("1")>, "one", <(literal.(type))("0")>, "zero");
        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("2")>, "two", <(literal.(type))("5")>, "five");
        Mutable<name>ObjectMap\<String> map4 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("5")>, "five");
        final String[] concat = {"", "", "", ""};

        map1.forEachWith(new Procedure2\<String, String>()
        {
            public void value(String argument1, String argument2)
            {
                concat[0] += argument1;
                concat[0] += argument2;
            }
        }, "-");
        map2.forEachWith(new Procedure2\<String, String>()
        {
            public void value(String argument1, String argument2)
            {
                concat[1] += argument1;
                concat[1] += argument2;
            }
        }, "-");
        map3.forEachWith(new Procedure2\<String, String>()
        {
            public void value(String argument1, String argument2)
            {
                concat[2] += argument1;
                concat[2] += argument2;
            }
        }, "-");
        map4.forEachWith(new Procedure2\<String, String>()
        {
            public void value(String argument1, String argument2)
            {
                concat[3] += argument1;
                concat[3] += argument2;
            }
        }, "-");

        Assert.assertTrue(concat[0], "one-five-".equals(concat[0]) || "five-one-".equals(concat[0]));
        Assert.assertTrue(concat[1], "one-zero-".equals(concat[1]) || "zero-one-".equals(concat[1]));
        Assert.assertTrue(concat[2], "two-five-".equals(concat[2]) || "five-two-".equals(concat[2]));
        Assert.assertTrue(concat[3], "zero-five-".equals(concat[3]) || "five-zero-".equals(concat[3]));
    }

    @Test
    public void iterator()
    {
        UnifiedSet\<String> expected = UnifiedSet.newSetWith("zero", "one", "thirtyOne", "thirtyTwo");
        UnifiedSet\<String> actual = UnifiedSet.newSet();
        this.map.put(<(literal.(type))("1")>, "one");

        final Iterator\<String> iterator = this.map.iterator();
        Assert.assertTrue(iterator.hasNext());
        actual.add(iterator.next());
        Assert.assertTrue(iterator.hasNext());
        actual.add(iterator.next());
        Assert.assertTrue(iterator.hasNext());
        actual.add(iterator.next());
        Assert.assertTrue(iterator.hasNext());
        actual.add(iterator.next());
        Assert.assertFalse(iterator.hasNext());

        Assert.assertEquals(expected, actual);
        Verify.assertThrows(NoSuchElementException.class, new Runnable()
        {
            public void run()
            {
                iterator.next();
            }
        });

        Mutable<name>ObjectMap\<String> map1 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("1")>, "one");
        final Iterator\<String> iterator1 = map1.iterator();
        Verify.assertThrows(IllegalStateException.class, new Runnable()
        {
            public void run()
            {
                iterator1.remove();
            }
        });
        iterator1.next();
        iterator1.remove();
        Assert.assertTrue(map1.toString(), <name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero").equals(map1)
                || <name>ObjectHashMap.newWithKeysValues(<(literal.(type))("1")>, "one").equals(map1));
        iterator1.next();
        iterator1.remove();
        Assert.assertEquals(<name>ObjectHashMap.newMap(), map1);
        Verify.assertThrows(IllegalStateException.class, new Runnable()
        {
            public void run()
            {
                iterator1.remove();
            }
        });

        Mutable<name>ObjectMap\<String> map2 = this.newWithKeysValues(<(literal.(type))("0")>, "zero", <(literal.(type))("9")>, "nine");
        final Iterator\<String> iterator2 = map2.iterator();
        Verify.assertThrows(IllegalStateException.class, new Runnable()
        {
            public void run()
            {
                iterator2.remove();
            }
        });
        iterator2.next();
        iterator2.remove();
        Assert.assertTrue(map2.toString(), <name>ObjectHashMap.newWithKeysValues(<(literal.(type))("0")>, "zero").equals(map2)
                || <name>ObjectHashMap.newWithKeysValues(<(literal.(type))("9")>, "nine").equals(map2));
        iterator2.next();
        iterator2.remove();
        Assert.assertEquals(<name>ObjectHashMap.newMap(), map2);

        Mutable<name>ObjectMap\<String> map3 = this.newWithKeysValues(<(literal.(type))("8")>, "eight", <(literal.(type))("9")>, "nine");
        final Iterator\<String> iterator3 = map3.iterator();
        Verify.assertThrows(IllegalStateException.class, new Runnable()
        {
            public void run()
            {
                iterator3.remove();
            }
        });
        iterator3.next();
        iterator3.remove();
        Assert.assertTrue(map3.toString(), <name>ObjectHashMap.newWithKeysValues(<(literal.(type))("8")>, "eight").equals(map3)
                || <name>ObjectHashMap.newWithKeysValues(<(literal.(type))("9")>, "nine").equals(map3));
        iterator3.next();
        iterator3.remove();
        Assert.assertEquals(<name>ObjectHashMap.newMap(), map3);
    }

    @Test
    public void asUnmodifiable()
    {
        Verify.assertInstanceOf(Unmodifiable<name>ObjectMap.class, this.map.asUnmodifiable());
        Assert.assertEquals(new Unmodifiable<name>ObjectMap\<String>(this.map), this.map.asUnmodifiable());
    }

    @Test
    public void asSynchronized()
    {
        Verify.assertInstanceOf(Synchronized<name>ObjectMap.class, this.map.asSynchronized());
        Assert.assertEquals(new Synchronized<name>ObjectMap\<String>(this.map), this.map.asSynchronized());
    }
}

>>
